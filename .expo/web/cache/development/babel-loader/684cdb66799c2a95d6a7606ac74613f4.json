{"ast":null,"code":"\"use strict\";\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AccessibilityUtil from \"../../modules/AccessibilityUtil\";\nimport BoundingDimensions from \"./BoundingDimensions\";\nimport findNodeHandle from \"../findNodeHandle\";\nimport normalizeColor from \"normalize-css-color\";\nimport Position from \"./Position\";\nimport React from \"react\";\nimport UIManager from \"../UIManager\";\nimport View from \"../View\";\nvar extractSingleTouch = function extractSingleTouch(nativeEvent) {\n  var touches = nativeEvent.touches;\n  var changedTouches = nativeEvent.changedTouches;\n  var hasTouches = touches && touches.length > 0;\n  var hasChangedTouches = changedTouches && changedTouches.length > 0;\n  return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;\n};\nvar States = {\n  NOT_RESPONDER: \"NOT_RESPONDER\",\n  RESPONDER_INACTIVE_PRESS_IN: \"RESPONDER_INACTIVE_PRESS_IN\",\n  RESPONDER_INACTIVE_PRESS_OUT: \"RESPONDER_INACTIVE_PRESS_OUT\",\n  RESPONDER_ACTIVE_PRESS_IN: \"RESPONDER_ACTIVE_PRESS_IN\",\n  RESPONDER_ACTIVE_PRESS_OUT: \"RESPONDER_ACTIVE_PRESS_OUT\",\n  RESPONDER_ACTIVE_LONG_PRESS_IN: \"RESPONDER_ACTIVE_LONG_PRESS_IN\",\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: \"RESPONDER_ACTIVE_LONG_PRESS_OUT\",\n  ERROR: \"ERROR\"\n};\nvar baseStatesConditions = {\n  NOT_RESPONDER: false,\n  RESPONDER_INACTIVE_PRESS_IN: false,\n  RESPONDER_INACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_PRESS_IN: false,\n  RESPONDER_ACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: false,\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: false,\n  ERROR: false\n};\nvar IsActive = _objectSpread(_objectSpread({}, baseStatesConditions), {}, {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n});\nvar IsPressingIn = _objectSpread(_objectSpread({}, baseStatesConditions), {}, {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\nvar IsLongPressingIn = _objectSpread(_objectSpread({}, baseStatesConditions), {}, {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\nvar Signals = {\n  DELAY: \"DELAY\",\n  RESPONDER_GRANT: \"RESPONDER_GRANT\",\n  RESPONDER_RELEASE: \"RESPONDER_RELEASE\",\n  RESPONDER_TERMINATED: \"RESPONDER_TERMINATED\",\n  ENTER_PRESS_RECT: \"ENTER_PRESS_RECT\",\n  LEAVE_PRESS_RECT: \"LEAVE_PRESS_RECT\",\n  LONG_PRESS_DETECTED: \"LONG_PRESS_DETECTED\"\n};\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n};\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\nvar TouchableMixin = {\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n    this._touchableNode = findNodeHandle(this);\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = function (e) {\n        if (_this._isTouchableKeyboardActive) {\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            _this.touchableHandleResponderTerminate({\n              nativeEvent: e\n            });\n          }\n          _this._isTouchableKeyboardActive = false;\n        }\n      };\n      this._touchableNode.addEventListener(\"blur\", this._touchableBlurListener);\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener(\"blur\", this._touchableBlurListener);\n    }\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressInLocation = null;\n    this.state.touchable.responderID = null;\n    this._touchableNode = null;\n  },\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget;\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this._handleDelay(e);\n    }\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this.pressInLocation = null;\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this.pressInLocation = null;\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left || 0;\n      pressExpandTop += hitSlop.top || 0;\n      pressExpandRight += hitSlop.right || 0;\n      pressExpandBottom += hitSlop.bottom || 0;\n    }\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n    if (isTouchWithinActive) {\n      var prevState = this.state.touchable.touchState;\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n      var curState = this.state.touchable.touchState;\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n  touchableHandleFocus: function touchableHandleFocus(e) {\n    this.props.onFocus && this.props.onFocus(e);\n  },\n  touchableHandleBlur: function touchableHandleBlur(e) {\n    this.props.onBlur && this.props.onBlur(e);\n  },\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n    if (tag == null) {\n      return;\n    }\n    UIManager.measure(tag, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {\n    if (!l && !t && !w && !h && !globalX && !globalY) {\n      return;\n    }\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error(\"Attempted to transition from state `\" + curState + \"` to `\" + States.RESPONDER_ACTIVE_LONG_PRESS_IN + \"`, which is not supported. This is \" + \"most likely due to `Touchable.longPressDelayTimeout` not being cancelled.\");\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n    if (!nextState) {\n      throw new Error(\"Unrecognized signal `\" + signal + \"` or state `\" + curState + \"` for Touchable responder `\" + responderID + \"`\");\n    }\n    if (nextState === States.ERROR) {\n      throw new Error(\"Touchable cannot transition from `\" + curState + \"` to `\" + signal + \"` for responder `\" + responderID + \"`\");\n    }\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n      locationX: locationX,\n      locationY: locationY\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n    var newIsHighlight = this._isHighlight(nextState);\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n    var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;\n    var isActiveTransition = !IsActive[curState] && IsActive[nextState];\n    if (isInitialTransition || isActiveTransition) {\n      this._remeasureMetricsOnActivation();\n    }\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          this._startHighlight(e);\n          this._endHighlight(e);\n        }\n        this.touchableHandlePress(e);\n      }\n    }\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n  _playTouchSound: function _playTouchSound() {\n    UIManager.playTouchSound();\n  },\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n  _endHighlight: function _endHighlight(e) {\n    var _this2 = this;\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this2.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var type = e.type,\n      key = e.key;\n    if (key === \"Enter\" || key === \" \") {\n      if (type === \"keydown\") {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === \"keyup\") {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n      e.stopPropagation();\n      if (!(key === \"Enter\" && AccessibilityUtil.propsToAriaRole(this.props) === \"link\")) {\n        e.preventDefault();\n      }\n    }\n  },\n  withoutDefaultFocusAndBlur: {}\n};\nvar touchableHandleFocus = TouchableMixin.touchableHandleFocus,\n  touchableHandleBlur = TouchableMixin.touchableHandleBlur,\n  TouchableMixinWithoutDefaultFocusAndBlur = _objectWithoutPropertiesLoose(TouchableMixin, [\"touchableHandleFocus\", \"touchableHandleBlur\"]);\nTouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false,\n  renderDebugView: function renderDebugView(_ref) {\n    var color = _ref.color,\n      hitSlop = _ref.hitSlop;\n    if (!Touchable.TOUCH_TARGET_DEBUG) {\n      return null;\n    }\n    if (\"development\" !== \"production\") {\n      throw Error(\"Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!\");\n    }\n    var debugHitSlopStyle = {};\n    hitSlop = hitSlop || {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    for (var key in hitSlop) {\n      debugHitSlopStyle[key] = -hitSlop[key];\n    }\n    var normalizedColor = normalizeColor(color);\n    if (typeof normalizedColor !== \"number\") {\n      return null;\n    }\n    var hexColor = \"#\" + (\"00000000\" + normalizedColor.toString(16)).substr(-8);\n    return React.createElement(View, {\n      pointerEvents: \"none\",\n      style: _objectSpread({\n        position: \"absolute\",\n        borderColor: hexColor.slice(0, -2) + \"55\",\n        borderWidth: 1,\n        borderStyle: \"dashed\",\n        backgroundColor: hexColor.slice(0, -2) + \"0F\"\n      }, debugHitSlopStyle)\n    });\n  }\n};\nexport default Touchable;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/exports/Touchable/index.js"],"names":["_objectWithoutPropertiesLoose","_objectSpread","AccessibilityUtil","BoundingDimensions","findNodeHandle","normalizeColor","Position","React","UIManager","View","extractSingleTouch","nativeEvent","touches","changedTouches","hasTouches","length","hasChangedTouches","States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","baseStatesConditions","IsActive","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","TouchableMixin","componentDidMount","_touchableNode","addEventListener","_touchableBlurListener","e","_isTouchableKeyboardActive","state","touchable","touchState","touchableHandleResponderTerminate","componentWillUnmount","removeEventListener","touchableDelayTimeout","clearTimeout","longPressDelayTimeout","pressOutDelayTimeout","pressInLocation","responderID","touchableGetInitialState","undefined","touchableHandleResponderTerminationRequest","props","rejectResponderTermination","touchableHandleStartShouldSetResponder","disabled","touchableLongPressCancelsPress","touchableHandleResponderGrant","dispatchID","currentTarget","persist","_receiveSignal","delayMS","touchableGetHighlightDelayMS","Math","max","isNaN","setTimeout","_handleDelay","bind","longDelayMS","touchableGetLongPressDelayMS","_handleLongDelay","touchableHandleResponderRelease","touchableHandleResponderMove","positionOnActivate","dimensionsOnActivate","pressRectOffset","touchableGetPressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touchableGetHitSlop","touch","pageX","pageY","movedDistance","_getDistanceBetweenPoints","_cancelLongPressDelayTimeout","isTouchWithinActive","width","height","prevState","curState","touchableHandleFocus","onFocus","touchableHandleBlur","onBlur","_remeasureMetricsOnActivation","tag","measure","_handleQueryLayout","l","t","w","h","globalX","globalY","release","getPooled","console","signal","nextState","Error","_performSideEffectsForTransition","_isHighlight","_savePressInLocation","locationX","locationY","aX","aY","bX","bY","deltaX","deltaY","sqrt","curIsHighlight","newIsHighlight","isFinalSignal","isInitialTransition","isActiveTransition","touchableHandleLongPress","_startHighlight","_endHighlight","hasLongPressHandler","onLongPress","pressIsLongButStillCallOnPress","shouldInvokePress","touchableHandlePress","_playTouchSound","playTouchSound","touchableHandleActivePressIn","touchableHandleActivePressOut","touchableGetPressOutDelayMS","touchableHandleKeyEvent","type","key","stopPropagation","propsToAriaRole","preventDefault","withoutDefaultFocusAndBlur","TouchableMixinWithoutDefaultFocusAndBlur","Touchable","Mixin","TOUCH_TARGET_DEBUG","renderDebugView","_ref","color","process","debugHitSlopStyle","normalizedColor","hexColor","toString","substr","createElement","pointerEvents","style","position","borderColor","slice","borderWidth","borderStyle","backgroundColor"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AccessibilityUtil from '../../modules/AccessibilityUtil';\nimport BoundingDimensions from './BoundingDimensions';\nimport findNodeHandle from '../findNodeHandle';\nimport normalizeColor from 'normalize-css-color';\nimport Position from './Position';\nimport React from 'react';\nimport UIManager from '../UIManager';\nimport View from '../View';\n\nvar extractSingleTouch = nativeEvent => {\n  var touches = nativeEvent.touches;\n  var changedTouches = nativeEvent.changedTouches;\n  var hasTouches = touches && touches.length > 0;\n  var hasChangedTouches = changedTouches && changedTouches.length > 0;\n  return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;\n};\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\n\n\nvar States = {\n  NOT_RESPONDER: 'NOT_RESPONDER',\n  // Not the responder\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',\n  // Responder, inactive, in the `PressRect`\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',\n  // Responder, inactive, out of `PressRect`\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',\n  // Responder, active, in the `PressRect`\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',\n  // Responder, active, out of `PressRect`\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  // Responder, active, in the `PressRect`, after long press threshold\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n  // Responder, active, out of `PressRect`, after long press threshold\n  ERROR: 'ERROR'\n};\n\n/*\n * Quick lookup map for states that are considered to be \"active\"\n */\nvar baseStatesConditions = {\n  NOT_RESPONDER: false,\n  RESPONDER_INACTIVE_PRESS_IN: false,\n  RESPONDER_INACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_PRESS_IN: false,\n  RESPONDER_ACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: false,\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: false,\n  ERROR: false\n};\n\nvar IsActive = _objectSpread(_objectSpread({}, baseStatesConditions), {}, {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n});\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\n\n\nvar IsPressingIn = _objectSpread(_objectSpread({}, baseStatesConditions), {}, {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\n\nvar IsLongPressingIn = _objectSpread(_objectSpread({}, baseStatesConditions), {}, {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\n/**\n * Inputs to the state machine.\n */\n\n\nvar Signals = {\n  DELAY: 'DELAY',\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\n};\n\n/**\n * Mapping from States x Signals => States\n */\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n}; // ==== Typical Constants for integrating into UI components ====\n// var HIT_EXPAND_PX = 20;\n// var HIT_VERT_OFFSET_PX = 10;\n\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10; // Default amount \"active\" region protrudes beyond box\n\n/**\n * By convention, methods prefixed with underscores are meant to be @private,\n * and not @protected. Mixers shouldn't access them - not even to provide them\n * as callback handlers.\n *\n *\n * ========== Geometry =========\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n *  +--------------------------+\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\n *  |  +--------------------+  |   to become the responder.\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\n *  |  |  |              |  |  |   and before letting up, the Visual React\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\n *  |  |     HitRect        |  |   for being highlighted (so long as the\n *  |  +--------------------+  |   press remains in the `PressRect`).\n *  |        PressRect     o   |\n *  +----------------------|---+\n *           Out Region    |\n *                         +-----+ This gap between the `HitRect` and\n *                                 `PressRect` allows a touch to move far away\n *                                 from the original hit rect, and remain\n *                                 highlighted, and eligible for a \"Press\".\n *                                 Customize this via\n *                                 `touchableGetPressRectOffset()`.\n *\n *\n *\n * ======= State Machine =======\n *\n * +-------------+ <---+ RESPONDER_RELEASE\n * |NOT_RESPONDER|\n * +-------------+ <---+ RESPONDER_TERMINATED\n *     +\n *     | RESPONDER_GRANT (HitRect)\n *     v\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\n * +---------------------------+          +-------------------------+                +------------------------------+\n *     +            ^                         +           ^                                 +           ^\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\n *     |            |                         |           |                                 |           |\n *     v            +                         v           +                                 v           +\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\n * +----------------------------+         +--------------------------+               +-------------------------------+\n *\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the `touchableHandlePress` abstract method invocation that occurs\n * when a responder is released while in either of the \"Press\" states.\n *\n * The other important side effects are the highlight abstract method\n * invocations (internal callbacks) to be implemented by the mixer.\n *\n *\n * @lends Touchable.prototype\n */\n\nvar TouchableMixin = {\n  // HACK (part 1): basic support for touchable interactions using a keyboard\n  componentDidMount: function componentDidMount() {\n    this._touchableNode = findNodeHandle(this);\n\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = e => {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderTerminate({\n              nativeEvent: e\n            });\n          }\n\n          this._isTouchableKeyboardActive = false;\n        }\n      };\n\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\n    }\n  },\n\n  /**\n   * Clear all timeouts on unmount\n   */\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout); // Clear DOM nodes\n\n    this.pressInLocation = null;\n    this.state.touchable.responderID = null;\n    this._touchableNode = null;\n  },\n\n  /**\n   * It's prefer that mixins determine state in this way, having the class\n   * explicitly mix the state in the one and only `getInitialState` method.\n   *\n   * @return {object} State object to be placed inside of\n   * `this.state.touchable`.\n   */\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  // ==== Hooks to Gesture Responder system ====\n\n  /**\n   * Must return true if embedded in a native platform scroll view.\n   */\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n\n  /**\n   * Must return true to start the process of `Touchable`.\n   */\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n\n  /**\n   * Return true to cancel press on long press.\n   */\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderGrant` event.\n   * @param {SyntheticEvent} e Synthetic event from event system.\n   *\n   */\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget; // Since e is used in a callback invoked on another event loop\n    // (as in setTimeout etc), we need to call e.persist() on the\n    // event to make sure it doesn't get reused in the event object pool.\n\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderRelease` event.\n   */\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this.pressInLocation = null;\n\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderTerminate` event.\n   */\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this.pressInLocation = null;\n\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderMove` event.\n   */\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    // Measurement may not have returned yet.\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left || 0;\n      pressExpandTop += hitSlop.top || 0;\n      pressExpandRight += hitSlop.right || 0;\n      pressExpandBottom += hitSlop.bottom || 0;\n    }\n\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n\n    if (isTouchWithinActive) {\n      var prevState = this.state.touchable.touchState;\n\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n\n      var curState = this.state.touchable.touchState;\n\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {\n        // fix for t7967420\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  /**\n   * Invoked when the item receives focus. Mixers might override this to\n   * visually distinguish the `VisualRect` so that the user knows that it\n   * currently has the focus. Most platforms only support a single element being\n   * focused at a time, in which case there may have been a previously focused\n   * element that was blurred just prior to this. This can be overridden when\n   * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.\n   */\n  touchableHandleFocus: function touchableHandleFocus(e) {\n    this.props.onFocus && this.props.onFocus(e);\n  },\n\n  /**\n   * Invoked when the item loses focus. Mixers might override this to\n   * visually distinguish the `VisualRect` so that the user knows that it\n   * no longer has focus. Most platforms only support a single element being\n   * focused at a time, in which case the focus may have moved to another.\n   * This can be overridden when using\n   * `Touchable.Mixin.withoutDefaultFocusAndBlur`.\n   */\n  touchableHandleBlur: function touchableHandleBlur(e) {\n    this.props.onBlur && this.props.onBlur(e);\n  },\n  // ==== Abstract Application Callbacks ====\n\n  /**\n   * Invoked when the item should be highlighted. Mixers should implement this\n   * to visually distinguish the `VisualRect` so that the user knows that\n   * releasing a touch will result in a \"selection\" (analog to click).\n   *\n   * @abstract\n   * touchableHandleActivePressIn: function,\n   */\n\n  /**\n   * Invoked when the item is \"active\" (in that it is still eligible to become\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n   * again and the mixer should probably highlight the `VisualRect` again. This\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\n   * the user is depressing the mouse/touch.\n   *\n   * @abstract\n   * touchableHandleActivePressOut: function\n   */\n\n  /**\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\n   * letting up while the item was either in the state\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n   *\n   * @abstract\n   * touchableHandlePress: function\n   */\n\n  /**\n   * Invoked when the item is long pressed - meaning the interaction ended by\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\n   * default any `touchableHandlePress` callback will not be invoked. To\n   * override this default behavior, override `touchableLongPressCancelsPress`\n   * to return false. As a result, `touchableHandlePress` will be called when\n   * lifting up, even if `touchableHandleLongPress` has also been called.\n   *\n   * @abstract\n   * touchableHandleLongPress: function\n   */\n\n  /**\n   * Returns the number of millis to wait before triggering a highlight.\n   *\n   * @abstract\n   * touchableGetHighlightDelayMS: function\n   */\n\n  /**\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n   * numbers mean the size expands outwards.\n   *\n   * @abstract\n   * touchableGetPressRectOffset: function\n   */\n  // ==== Internal Logic ====\n\n  /**\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n   * should result in points that are in the same coordinate system as an\n   * event's `globalX/globalY` data values.\n   *\n   * - Consider caching this for the lifetime of the component, or possibly\n   *   being able to share this cache between any `ScrollMap` view.\n   *\n   * @sideeffects\n   * @private\n   */\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n\n    if (tag == null) {\n      return;\n    }\n\n    UIManager.measure(tag, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {\n    //don't do anything UIManager failed to measure node\n    if (!l && !t && !w && !h && !globalX && !globalY) {\n      return;\n    }\n\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && // $FlowFixMe\n    BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY); // $FlowFixMe\n\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   *\n   * @param {Signals} signal State machine signal.\n   * @throws Error if invalid state transition or unrecognized signal.\n   * @sideeffects\n   */\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = {\n      pageX,\n      pageY,\n      locationX,\n      locationY\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n\n  /**\n   * Will perform a transition between touchable states, and identify any\n   * highlighting or unhighlighting that must be performed for this particular\n   * transition.\n   *\n   * @param {States} curState Current Touchable state.\n   * @param {States} nextState Next Touchable state.\n   * @param {Signal} signal Signal that triggered the transition.\n   * @param {Event} e Native event.\n   * @sideeffects\n   */\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;\n    var isActiveTransition = !IsActive[curState] && IsActive[nextState];\n\n    if (isInitialTransition || isActiveTransition) {\n      this._remeasureMetricsOnActivation();\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing.. // But either has no long handler\n      !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.\n\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          // we never highlighted because of delay, but we should highlight now\n          this._startHighlight(e);\n\n          this._endHighlight(e);\n        }\n\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n  _playTouchSound: function _playTouchSound() {\n    UIManager.playTouchSound();\n  },\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n  _endHighlight: function _endHighlight(e) {\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(() => {\n          this.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n  // HACK (part 2): basic support for touchable interactions using a keyboard (including\n  // delays and longPress)\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var type = e.type,\n        key = e.key;\n\n    if (key === 'Enter' || key === ' ') {\n      if (type === 'keydown') {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === 'keyup') {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n\n      e.stopPropagation(); // prevent the default behaviour unless the Touchable functions as a link\n      // and Enter is pressed\n\n      if (!(key === 'Enter' && AccessibilityUtil.propsToAriaRole(this.props) === 'link')) {\n        e.preventDefault();\n      }\n    }\n  },\n  withoutDefaultFocusAndBlur: {}\n};\n/**\n * Provide an optional version of the mixin where `touchableHandleFocus` and\n * `touchableHandleBlur` can be overridden. This allows appropriate defaults to\n * be set on TV platforms, without breaking existing implementations of\n * `Touchable`.\n */\n\nvar touchableHandleFocus = TouchableMixin.touchableHandleFocus,\n    touchableHandleBlur = TouchableMixin.touchableHandleBlur,\n    TouchableMixinWithoutDefaultFocusAndBlur = _objectWithoutPropertiesLoose(TouchableMixin, [\"touchableHandleFocus\", \"touchableHandleBlur\"]);\n\nTouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false,\n  // Highlights all touchable targets. Toggle with Inspector.\n\n  /**\n   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).\n   */\n  renderDebugView: _ref => {\n    var color = _ref.color,\n        hitSlop = _ref.hitSlop;\n\n    if (!Touchable.TOUCH_TARGET_DEBUG) {\n      return null;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');\n    }\n\n    var debugHitSlopStyle = {};\n    hitSlop = hitSlop || {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    for (var key in hitSlop) {\n      debugHitSlopStyle[key] = -hitSlop[key];\n    }\n\n    var normalizedColor = normalizeColor(color);\n\n    if (typeof normalizedColor !== 'number') {\n      return null;\n    }\n\n    var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);\n    return /*#__PURE__*/React.createElement(View, {\n      pointerEvents: \"none\",\n      style: _objectSpread({\n        position: 'absolute',\n        borderColor: hexColor.slice(0, -2) + '55',\n        // More opaque\n        borderWidth: 1,\n        borderStyle: 'dashed',\n        backgroundColor: hexColor.slice(0, -2) + '0F'\n      }, debugHitSlopStyle)\n    });\n  }\n};\nexport default Touchable;"]},"metadata":{},"sourceType":"module"}