{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AnimatedNode from \"./AnimatedNode\";\nimport AnimatedWithChildren from \"./AnimatedWithChildren\";\nimport NativeAnimatedHelper from \"../NativeAnimatedHelper\";\nimport invariant from \"fbjs/lib/invariant\";\nimport normalizeColor from \"normalize-css-color\";\nvar __DEV__ = \"development\" !== \"production\";\nvar linear = function linear(t) {\n  return t;\n};\nfunction createInterpolation(config) {\n  if (config.outputRange && typeof config.outputRange[0] === \"string\") {\n    return createInterpolationFromStringOutputRange(config);\n  }\n  var outputRange = config.outputRange;\n  checkInfiniteRange(\"outputRange\", outputRange);\n  var inputRange = config.inputRange;\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkValidInputRange(inputRange);\n  invariant(inputRange.length === outputRange.length, \"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  var easing = config.easing || linear;\n  var extrapolateLeft = \"extend\";\n  if (config.extrapolateLeft !== undefined) {\n    extrapolateLeft = config.extrapolateLeft;\n  } else if (config.extrapolate !== undefined) {\n    extrapolateLeft = config.extrapolate;\n  }\n  var extrapolateRight = \"extend\";\n  if (config.extrapolateRight !== undefined) {\n    extrapolateRight = config.extrapolateRight;\n  } else if (config.extrapolate !== undefined) {\n    extrapolateRight = config.extrapolate;\n  }\n  return function (input) {\n    invariant(typeof input === \"number\", \"Cannot interpolation an input which is not a number\");\n    var range = findRange(input, inputRange);\n    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);\n  };\n}\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {\n  var result = input;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    } else if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"extend\") {}\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    } else if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"extend\") {}\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  if (inputMin === inputMax) {\n    if (input <= inputMin) {\n      return outputMin;\n    }\n    return outputMax;\n  }\n  if (inputMin === -Infinity) {\n    result = -result;\n  } else if (inputMax === Infinity) {\n    result = result - inputMin;\n  } else {\n    result = (result - inputMin) / (inputMax - inputMin);\n  }\n  result = easing(result);\n  if (outputMin === -Infinity) {\n    result = -result;\n  } else if (outputMax === Infinity) {\n    result = result + outputMin;\n  } else {\n    result = result * (outputMax - outputMin) + outputMin;\n  }\n  return result;\n}\nfunction colorToRgba(input) {\n  var normalizedColor = normalizeColor(input);\n  if (normalizedColor === null || typeof normalizedColor !== \"number\") {\n    return input;\n  }\n  normalizedColor = normalizedColor || 0;\n  var r = (normalizedColor & 0xff000000) >>> 24;\n  var g = (normalizedColor & 0x00ff0000) >>> 16;\n  var b = (normalizedColor & 0x0000ff00) >>> 8;\n  var a = (normalizedColor & 0x000000ff) / 255;\n  return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n}\nvar stringShapeRegex = /[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?/g;\nfunction createInterpolationFromStringOutputRange(config) {\n  var outputRange = config.outputRange;\n  invariant(outputRange.length >= 2, \"Bad output range\");\n  outputRange = outputRange.map(colorToRgba);\n  checkPattern(outputRange);\n  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {\n    return [];\n  });\n  outputRange.forEach(function (value) {\n    value.match(stringShapeRegex).forEach(function (number, i) {\n      outputRanges[i].push(+number);\n    });\n  });\n  var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {\n    return createInterpolation(_objectSpread(_objectSpread({}, config), {}, {\n      outputRange: outputRanges[i]\n    }));\n  });\n  var shouldRound = isRgbOrRgba(outputRange[0]);\n  return function (input) {\n    var i = 0;\n    return outputRange[0].replace(stringShapeRegex, function () {\n      var val = +interpolations[i++](input);\n      if (shouldRound) {\n        val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;\n      }\n      return String(val);\n    });\n  };\n}\nfunction isRgbOrRgba(range) {\n  return typeof range === \"string\" && range.startsWith(\"rgb\");\n}\nfunction checkPattern(arr) {\n  var pattern = arr[0].replace(stringShapeRegex, \"\");\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(pattern === arr[i].replace(stringShapeRegex, \"\"), \"invalid pattern \" + arr[0] + \" and \" + arr[i]);\n  }\n}\nfunction findRange(input, inputRange) {\n  var i;\n  for (i = 1; i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  invariant(arr.length >= 2, \"inputRange must have at least 2 elements\");\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(arr[i] >= arr[i - 1], \"inputRange must be monotonically non-decreasing \" + arr);\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  invariant(arr.length >= 2, name + \" must have at least 2 elements\");\n  invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity, name + \"cannot be ]-infinity;+infinity[ \" + arr);\n}\nvar AnimatedInterpolation = function (_AnimatedWithChildren) {\n  _inherits(AnimatedInterpolation, _AnimatedWithChildren);\n  var _super = _createSuper(AnimatedInterpolation);\n  function AnimatedInterpolation(parent, config) {\n    var _this;\n    _classCallCheck(this, AnimatedInterpolation);\n    _this = _super.call(this);\n    _this._parent = parent;\n    _this._config = config;\n    _this._interpolation = createInterpolation(config);\n    return _this;\n  }\n  _createClass(AnimatedInterpolation, [{\n    key: \"__makeNative\",\n    value: function __makeNative() {\n      this._parent.__makeNative();\n      _get(_getPrototypeOf(AnimatedInterpolation.prototype), \"__makeNative\", this).call(this);\n    }\n  }, {\n    key: \"__getValue\",\n    value: function __getValue() {\n      var parentValue = this._parent.__getValue();\n      invariant(typeof parentValue === \"number\", \"Cannot interpolate an input which is not a number.\");\n      return this._interpolation(parentValue);\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(config) {\n      return new AnimatedInterpolation(this, config);\n    }\n  }, {\n    key: \"__attach\",\n    value: function __attach() {\n      this._parent.__addChild(this);\n    }\n  }, {\n    key: \"__detach\",\n    value: function __detach() {\n      this._parent.__removeChild(this);\n      _get(_getPrototypeOf(AnimatedInterpolation.prototype), \"__detach\", this).call(this);\n    }\n  }, {\n    key: \"__transformDataType\",\n    value: function __transformDataType(range) {\n      return range.map(NativeAnimatedHelper.transformDataType);\n    }\n  }, {\n    key: \"__getNativeConfig\",\n    value: function __getNativeConfig() {\n      if (__DEV__) {\n        NativeAnimatedHelper.validateInterpolation(this._config);\n      }\n      return {\n        inputRange: this._config.inputRange,\n        outputRange: this.__transformDataType(this._config.outputRange),\n        extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || \"extend\",\n        extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || \"extend\",\n        type: \"interpolation\"\n      };\n    }\n  }]);\n  return AnimatedInterpolation;\n}(AnimatedWithChildren);\nAnimatedInterpolation.__createInterpolation = createInterpolation;\nexport default AnimatedInterpolation;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedInterpolation.js"],"names":["_objectSpread","AnimatedNode","AnimatedWithChildren","NativeAnimatedHelper","invariant","normalizeColor","__DEV__","process","linear","t","createInterpolation","config","outputRange","createInterpolationFromStringOutputRange","checkInfiniteRange","inputRange","checkValidInputRange","length","easing","extrapolateLeft","undefined","extrapolate","extrapolateRight","input","range","findRange","interpolate","inputMin","inputMax","outputMin","outputMax","result","Infinity","colorToRgba","normalizedColor","r","g","b","a","stringShapeRegex","map","checkPattern","outputRanges","match","forEach","value","number","i","push","interpolations","shouldRound","isRgbOrRgba","replace","val","Math","round","String","startsWith","arr","pattern","name","AnimatedInterpolation","constructor","parent","_parent","_config","_interpolation","__makeNative","__getValue","parentValue","__attach","__addChild","__detach","__removeChild","__transformDataType","transformDataType","__getNativeConfig","validateInterpolation","type","__createInterpolation"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n/* eslint no-bitwise: 0 */\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AnimatedNode from './AnimatedNode';\nimport AnimatedWithChildren from './AnimatedWithChildren';\nimport NativeAnimatedHelper from '../NativeAnimatedHelper';\nimport invariant from 'fbjs/lib/invariant';\nimport normalizeColor from 'normalize-css-color';\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar linear = t => t;\n/**\n * Very handy helper to map input ranges to output ranges with an easing\n * function and custom behavior outside of the ranges.\n */\n\n\nfunction createInterpolation(config) {\n  if (config.outputRange && typeof config.outputRange[0] === 'string') {\n    return createInterpolationFromStringOutputRange(config);\n  }\n\n  var outputRange = config.outputRange;\n  checkInfiniteRange('outputRange', outputRange);\n  var inputRange = config.inputRange;\n  checkInfiniteRange('inputRange', inputRange);\n  checkValidInputRange(inputRange);\n  invariant(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');\n  var easing = config.easing || linear;\n  var extrapolateLeft = 'extend';\n\n  if (config.extrapolateLeft !== undefined) {\n    extrapolateLeft = config.extrapolateLeft;\n  } else if (config.extrapolate !== undefined) {\n    extrapolateLeft = config.extrapolate;\n  }\n\n  var extrapolateRight = 'extend';\n\n  if (config.extrapolateRight !== undefined) {\n    extrapolateRight = config.extrapolateRight;\n  } else if (config.extrapolate !== undefined) {\n    extrapolateRight = config.extrapolate;\n  }\n\n  return input => {\n    invariant(typeof input === 'number', 'Cannot interpolation an input which is not a number');\n    var range = findRange(input, inputRange);\n    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);\n  };\n}\n\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {\n  var result = input; // Extrapolate\n\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') {\n      return result;\n    } else if (extrapolateLeft === 'clamp') {\n      result = inputMin;\n    } else if (extrapolateLeft === 'extend') {// noop\n    }\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') {\n      return result;\n    } else if (extrapolateRight === 'clamp') {\n      result = inputMax;\n    } else if (extrapolateRight === 'extend') {// noop\n    }\n  }\n\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n\n  if (inputMin === inputMax) {\n    if (input <= inputMin) {\n      return outputMin;\n    }\n\n    return outputMax;\n  } // Input Range\n\n\n  if (inputMin === -Infinity) {\n    result = -result;\n  } else if (inputMax === Infinity) {\n    result = result - inputMin;\n  } else {\n    result = (result - inputMin) / (inputMax - inputMin);\n  } // Easing\n\n\n  result = easing(result); // Output Range\n\n  if (outputMin === -Infinity) {\n    result = -result;\n  } else if (outputMax === Infinity) {\n    result = result + outputMin;\n  } else {\n    result = result * (outputMax - outputMin) + outputMin;\n  }\n\n  return result;\n}\n\nfunction colorToRgba(input) {\n  var normalizedColor = normalizeColor(input);\n\n  if (normalizedColor === null || typeof normalizedColor !== 'number') {\n    return input;\n  }\n\n  normalizedColor = normalizedColor || 0;\n  var r = (normalizedColor & 0xff000000) >>> 24;\n  var g = (normalizedColor & 0x00ff0000) >>> 16;\n  var b = (normalizedColor & 0x0000ff00) >>> 8;\n  var a = (normalizedColor & 0x000000ff) / 255;\n  return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n}\n\nvar stringShapeRegex = /[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?/g;\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *   rgba(123, 42, 99, 0.36) // colors\n *   -45deg                  // values with units\n */\n\nfunction createInterpolationFromStringOutputRange(config) {\n  var outputRange = config.outputRange;\n  invariant(outputRange.length >= 2, 'Bad output range');\n  outputRange = outputRange.map(colorToRgba);\n  checkPattern(outputRange); // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']\n  // ->\n  // [\n  //   [0, 50],\n  //   [100, 150],\n  //   [200, 250],\n  //   [0, 0.5],\n  // ]\n\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n\n  var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);\n  outputRange.forEach(value => {\n    /* $FlowFixMe(>=0.18.0): `value.match()` can return `null`. Need to guard\n     * against this possibility.\n     */\n    value.match(stringShapeRegex).forEach((number, i) => {\n      outputRanges[i].push(+number);\n    });\n  });\n  var interpolations = outputRange[0].match(stringShapeRegex)\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need\n   * to guard against this possibility. */\n  .map((value, i) => {\n    return createInterpolation(_objectSpread(_objectSpread({}, config), {}, {\n      outputRange: outputRanges[i]\n    }));\n  }); // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to\n  // round the opacity (4th column).\n\n  var shouldRound = isRgbOrRgba(outputRange[0]);\n  return input => {\n    var i = 0; // 'rgba(0, 100, 200, 0)'\n    // ->\n    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'\n\n    return outputRange[0].replace(stringShapeRegex, () => {\n      var val = +interpolations[i++](input);\n\n      if (shouldRound) {\n        val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;\n      }\n\n      return String(val);\n    });\n  };\n}\n\nfunction isRgbOrRgba(range) {\n  return typeof range === 'string' && range.startsWith('rgb');\n}\n\nfunction checkPattern(arr) {\n  var pattern = arr[0].replace(stringShapeRegex, '');\n\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);\n  }\n}\n\nfunction findRange(input, inputRange) {\n  var i;\n\n  for (i = 1; i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n\n  return i - 1;\n}\n\nfunction checkValidInputRange(arr) {\n  invariant(arr.length >= 2, 'inputRange must have at least 2 elements');\n\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(arr[i] >= arr[i - 1],\n    /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n     * one or both of the operands may be something that doesn't cleanly\n     * convert to a string, like undefined, null, and object, etc. If you really\n     * mean this implicit string conversion, you can do something like\n     * String(myThing)\n     */\n    'inputRange must be monotonically non-decreasing ' + arr);\n  }\n}\n\nfunction checkInfiniteRange(name, arr) {\n  invariant(arr.length >= 2, name + ' must have at least 2 elements');\n  invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,\n  /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n   * one or both of the operands may be something that doesn't cleanly convert\n   * to a string, like undefined, null, and object, etc. If you really mean\n   * this implicit string conversion, you can do something like\n   * String(myThing)\n   */\n  name + 'cannot be ]-infinity;+infinity[ ' + arr);\n}\n\nclass AnimatedInterpolation extends AnimatedWithChildren {\n  // Export for testing.\n  constructor(parent, config) {\n    super();\n    this._parent = parent;\n    this._config = config;\n    this._interpolation = createInterpolation(config);\n  }\n\n  __makeNative() {\n    this._parent.__makeNative();\n\n    super.__makeNative();\n  }\n\n  __getValue() {\n    var parentValue = this._parent.__getValue();\n\n    invariant(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');\n    return this._interpolation(parentValue);\n  }\n\n  interpolate(config) {\n    return new AnimatedInterpolation(this, config);\n  }\n\n  __attach() {\n    this._parent.__addChild(this);\n  }\n\n  __detach() {\n    this._parent.__removeChild(this);\n\n    super.__detach();\n  }\n\n  __transformDataType(range) {\n    return range.map(NativeAnimatedHelper.transformDataType);\n  }\n\n  __getNativeConfig() {\n    if (__DEV__) {\n      NativeAnimatedHelper.validateInterpolation(this._config);\n    }\n\n    return {\n      inputRange: this._config.inputRange,\n      // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here\n\n      /* $FlowFixMe(>=0.38.0) - Flow error detected during the deployment of\n       * v0.38.0. To see the error, remove this comment and run flow */\n      outputRange: this.__transformDataType(this._config.outputRange),\n      extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',\n      extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',\n      type: 'interpolation'\n    };\n  }\n\n}\n\nAnimatedInterpolation.__createInterpolation = createInterpolation;\nexport default AnimatedInterpolation;"]},"metadata":{},"sourceType":"module"}