{"ast":null,"code":"var _slicedToArray = require(\"/Users/VidhiKataria/Documents/Projects/testing123/node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\nvar $kC0mY$react = require(\"react\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useControlledState\", function () {\n  return $8d8fdfab47455712$export$40bfa8c7b0832715;\n});\n$parcel$export(module.exports, \"clamp\", function () {\n  return $ac8e4d4816275668$export$7d15b64cf5a3a4c4;\n});\n$parcel$export(module.exports, \"snapValueToStep\", function () {\n  return $ac8e4d4816275668$export$cb6e0bb50bc19463;\n});\n$parcel$export(module.exports, \"toFixedNumber\", function () {\n  return $ac8e4d4816275668$export$b6268554fba451f;\n});\nfunction $8d8fdfab47455712$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n  var _ref = (0, $kC0mY$react.useState)(value || defaultValue),\n    _ref2 = _slicedToArray(_ref, 2),\n    stateValue = _ref2[0],\n    setStateValue = _ref2[1];\n  var ref = (0, $kC0mY$react.useRef)(value !== undefined);\n  var wasControlled = ref.current;\n  var isControlled = value !== undefined;\n  var stateRef = (0, $kC0mY$react.useRef)(stateValue);\n  if (wasControlled !== isControlled) console.warn(\"WARN: A component changed from \" + (wasControlled ? \"controlled\" : \"uncontrolled\") + \" to \" + (isControlled ? \"controlled\" : \"uncontrolled\") + \".\");\n  ref.current = isControlled;\n  var setValue = (0, $kC0mY$react.useCallback)(function (value) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var onChangeCaller = function onChangeCaller(value) {\n      if (onChange) {\n        for (var _len2 = arguments.length, onChangeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          onChangeArgs[_key2 - 1] = arguments[_key2];\n        }\n        if (!Object.is(stateRef.current, value)) onChange.apply(void 0, [value].concat(onChangeArgs));\n      }\n      if (!isControlled) stateRef.current = value;\n    };\n    if (typeof value === \"function\") {\n      console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n      var _updateFunction = function _updateFunction(oldValue) {\n        for (var _len3 = arguments.length, functionArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          functionArgs[_key3 - 1] = arguments[_key3];\n        }\n        var interceptedValue = value.apply(void 0, [isControlled ? stateRef.current : oldValue].concat(functionArgs));\n        onChangeCaller.apply(void 0, [interceptedValue].concat(args));\n        if (!isControlled) return interceptedValue;\n        return oldValue;\n      };\n      setStateValue(_updateFunction);\n    } else {\n      if (!isControlled) setStateValue(value);\n      onChangeCaller.apply(void 0, [value].concat(args));\n    }\n  }, [isControlled, onChange]);\n  if (isControlled) stateRef.current = value;else value = stateValue;\n  return [value, setValue];\n}\nfunction $ac8e4d4816275668$export$7d15b64cf5a3a4c4(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\nfunction $ac8e4d4816275668$export$cb6e0bb50bc19463(value, min, max, step) {\n  var remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  var snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n  if (!isNaN(min)) {\n    if (snappedValue < min) snappedValue = min;else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n  } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n  var string = step.toString();\n  var index = string.indexOf(\".\");\n  var precision = index >= 0 ? string.length - index : 0;\n  if (precision > 0) {\n    var _pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * _pow) / _pow;\n  }\n  return snappedValue;\n}\nfunction $ac8e4d4816275668$export$b6268554fba451f(value, digits) {\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  var pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}","map":{"version":3,"sources":["packages/@react-stately/utils/src/useControlledState.ts","packages/@react-stately/utils/src/number.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T, ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320');\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n\n/* Takes a value and rounds off to the number of digits. */\nexport function toFixedNumber(value: number, digits: number, base: number = 10): number {\n  const pow = Math.pow(base, digits);\n\n  return Math.round(value * pow) / pow;\n}\n"]},"metadata":{},"sourceType":"script"}