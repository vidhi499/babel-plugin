{"ast":null,"code":"var _s = $RefreshSig$();\nimport { getModality } from \"../modality\";\nimport useEvent from \"../useEvent\";\nimport useLayoutEffect from \"../useLayoutEffect\";\nvar emptyObject = {};\nvar opts = {\n  passive: true\n};\nvar lockEventType = \"react-gui:hover:lock\";\nvar unlockEventType = \"react-gui:hover:unlock\";\nvar supportsPointerEvent = function supportsPointerEvent() {\n  return !!(\"object\" !== \"undefined\" && window.PointerEvent != null);\n};\nfunction dispatchCustomEvent(target, type, payload) {\n  var event = document.createEvent(\"CustomEvent\");\n  var _ref = payload || emptyObject,\n    _ref$bubbles = _ref.bubbles,\n    bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,\n    _ref$cancelable = _ref.cancelable,\n    cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,\n    detail = _ref.detail;\n  event.initCustomEvent(type, bubbles, cancelable, detail);\n  target.dispatchEvent(event);\n}\nfunction getPointerType(event) {\n  var pointerType = event.pointerType;\n  return pointerType != null ? pointerType : getModality();\n}\nexport default function useHover(targetRef, config) {\n  _s();\n  var contain = config.contain,\n    disabled = config.disabled,\n    onHoverStart = config.onHoverStart,\n    onHoverChange = config.onHoverChange,\n    onHoverUpdate = config.onHoverUpdate,\n    onHoverEnd = config.onHoverEnd;\n  var canUsePE = supportsPointerEvent();\n  var addMoveListener = useEvent(canUsePE ? \"pointermove\" : \"mousemove\", opts);\n  var addEnterListener = useEvent(canUsePE ? \"pointerenter\" : \"mouseenter\", opts);\n  var addLeaveListener = useEvent(canUsePE ? \"pointerleave\" : \"mouseleave\", opts);\n  var addLockListener = useEvent(lockEventType, opts);\n  var addUnlockListener = useEvent(unlockEventType, opts);\n  useLayoutEffect(function () {\n    var target = targetRef.current;\n    if (target !== null) {\n      var hoverEnd = function hoverEnd(e) {\n        if (onHoverEnd != null) {\n          onHoverEnd(e);\n        }\n        if (onHoverChange != null) {\n          onHoverChange(false);\n        }\n        addMoveListener(target, null);\n        addLeaveListener(target, null);\n      };\n      var leaveListener = function leaveListener(e) {\n        var target = targetRef.current;\n        if (target != null && getPointerType(e) !== \"touch\") {\n          if (contain) {\n            dispatchCustomEvent(target, unlockEventType);\n          }\n          hoverEnd(e);\n        }\n      };\n      var moveListener = function moveListener(e) {\n        if (getPointerType(e) !== \"touch\") {\n          if (onHoverUpdate != null) {\n            if (e.x == null) {\n              e.x = e.clientX;\n            }\n            if (e.y == null) {\n              e.y = e.clientY;\n            }\n            onHoverUpdate(e);\n          }\n        }\n      };\n      var hoverStart = function hoverStart(e) {\n        if (onHoverStart != null) {\n          onHoverStart(e);\n        }\n        if (onHoverChange != null) {\n          onHoverChange(true);\n        }\n        if (onHoverUpdate != null) {\n          addMoveListener(target, !disabled ? moveListener : null);\n        }\n        addLeaveListener(target, !disabled ? leaveListener : null);\n      };\n      var enterListener = function enterListener(e) {\n        var target = targetRef.current;\n        if (target != null && getPointerType(e) !== \"touch\") {\n          if (contain) {\n            dispatchCustomEvent(target, lockEventType);\n          }\n          hoverStart(e);\n          var lockListener = function lockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverEnd(e);\n            }\n          };\n          var unlockListener = function unlockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverStart(e);\n            }\n          };\n          addLockListener(target, !disabled ? lockListener : null);\n          addUnlockListener(target, !disabled ? unlockListener : null);\n        }\n      };\n      addEnterListener(target, !disabled ? enterListener : null);\n    }\n  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);\n}\n_s(useHover, \"g4iJ6GD4DJLwcOSoAglFYqEaawk=\", false, function () {\n  return [useEvent, useEvent, useEvent, useEvent, useEvent];\n});\n;\n;\n(function () {\n  var _a, _b;\n  if (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n    var currentExports = __webpack_module__.exports;\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      });\n      import.meta.webpackHot.accept();\n      if (prevExports !== null) {\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      var isNoLongerABoundary = prevExports !== null;\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/modules/useHover/index.js"],"names":["getModality","useEvent","useLayoutEffect","emptyObject","opts","passive","lockEventType","unlockEventType","supportsPointerEvent","window","PointerEvent","dispatchCustomEvent","target","type","payload","event","document","createEvent","_ref","_ref$bubbles","bubbles","_ref$cancelable","cancelable","detail","initCustomEvent","dispatchEvent","getPointerType","pointerType","useHover","targetRef","config","contain","disabled","onHoverStart","onHoverChange","onHoverUpdate","onHoverEnd","canUsePE","addMoveListener","addEnterListener","addLeaveListener","addLockListener","addUnlockListener","current","hoverEnd","e","leaveListener","moveListener","x","clientX","y","clientY","hoverStart","enterListener","lockListener","lockEvent","unlockListener"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getModality } from '../modality';\nimport useEvent from '../useEvent';\nimport useLayoutEffect from '../useLayoutEffect';\n/**\n * Types\n */\n\n/**\n * Implementation\n */\nvar emptyObject = {};\nvar opts = {\n  passive: true\n};\nvar lockEventType = 'react-gui:hover:lock';\nvar unlockEventType = 'react-gui:hover:unlock';\n\nvar supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);\n\nfunction dispatchCustomEvent(target, type, payload) {\n  var event = document.createEvent('CustomEvent');\n\n  var _ref = payload || emptyObject,\n      _ref$bubbles = _ref.bubbles,\n      bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,\n      _ref$cancelable = _ref.cancelable,\n      cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,\n      detail = _ref.detail;\n\n  event.initCustomEvent(type, bubbles, cancelable, detail);\n  target.dispatchEvent(event);\n} // This accounts for the non-PointerEvent fallback events.\n\n\nfunction getPointerType(event) {\n  var pointerType = event.pointerType;\n  return pointerType != null ? pointerType : getModality();\n}\n\nexport default function useHover(targetRef, config) {\n  var contain = config.contain,\n      disabled = config.disabled,\n      onHoverStart = config.onHoverStart,\n      onHoverChange = config.onHoverChange,\n      onHoverUpdate = config.onHoverUpdate,\n      onHoverEnd = config.onHoverEnd;\n  var canUsePE = supportsPointerEvent();\n  var addMoveListener = useEvent(canUsePE ? 'pointermove' : 'mousemove', opts);\n  var addEnterListener = useEvent(canUsePE ? 'pointerenter' : 'mouseenter', opts);\n  var addLeaveListener = useEvent(canUsePE ? 'pointerleave' : 'mouseleave', opts); // These custom events are used to implement the \"contain\" prop.\n\n  var addLockListener = useEvent(lockEventType, opts);\n  var addUnlockListener = useEvent(unlockEventType, opts);\n  useLayoutEffect(() => {\n    var target = targetRef.current;\n\n    if (target !== null) {\n      /**\n       * End the hover gesture\n       */\n      var hoverEnd = function hoverEnd(e) {\n        if (onHoverEnd != null) {\n          onHoverEnd(e);\n        }\n\n        if (onHoverChange != null) {\n          onHoverChange(false);\n        } // Remove the listeners once finished.\n\n\n        addMoveListener(target, null);\n        addLeaveListener(target, null);\n      };\n      /**\n       * Leave element\n       */\n\n\n      var leaveListener = function leaveListener(e) {\n        var target = targetRef.current;\n\n        if (target != null && getPointerType(e) !== 'touch') {\n          if (contain) {\n            dispatchCustomEvent(target, unlockEventType);\n          }\n\n          hoverEnd(e);\n        }\n      };\n      /**\n       * Move within element\n       */\n\n\n      var moveListener = function moveListener(e) {\n        if (getPointerType(e) !== 'touch') {\n          if (onHoverUpdate != null) {\n            // Not all browsers have these properties\n            if (e.x == null) {\n              e.x = e.clientX;\n            }\n\n            if (e.y == null) {\n              e.y = e.clientY;\n            }\n\n            onHoverUpdate(e);\n          }\n        }\n      };\n      /**\n       * Start the hover gesture\n       */\n\n\n      var hoverStart = function hoverStart(e) {\n        if (onHoverStart != null) {\n          onHoverStart(e);\n        }\n\n        if (onHoverChange != null) {\n          onHoverChange(true);\n        } // Set the listeners needed for the rest of the hover gesture.\n\n\n        if (onHoverUpdate != null) {\n          addMoveListener(target, !disabled ? moveListener : null);\n        }\n\n        addLeaveListener(target, !disabled ? leaveListener : null);\n      };\n      /**\n       * Enter element\n       */\n\n\n      var enterListener = function enterListener(e) {\n        var target = targetRef.current;\n\n        if (target != null && getPointerType(e) !== 'touch') {\n          if (contain) {\n            dispatchCustomEvent(target, lockEventType);\n          }\n\n          hoverStart(e);\n\n          var lockListener = function lockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverEnd(e);\n            }\n          };\n\n          var unlockListener = function unlockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverStart(e);\n            }\n          };\n\n          addLockListener(target, !disabled ? lockListener : null);\n          addUnlockListener(target, !disabled ? unlockListener : null);\n        }\n      };\n\n      addEnterListener(target, !disabled ? enterListener : null);\n    }\n  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);\n}"]},"metadata":{},"sourceType":"module"}