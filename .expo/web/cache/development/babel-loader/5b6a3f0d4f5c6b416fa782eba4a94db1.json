{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nexports.__esModule = true;\nexports.default = void 0;\nvar DELAY = \"DELAY\";\nvar ERROR = \"ERROR\";\nvar LONG_PRESS_DETECTED = \"LONG_PRESS_DETECTED\";\nvar NOT_RESPONDER = \"NOT_RESPONDER\";\nvar RESPONDER_ACTIVE_LONG_PRESS_START = \"RESPONDER_ACTIVE_LONG_PRESS_START\";\nvar RESPONDER_ACTIVE_PRESS_START = \"RESPONDER_ACTIVE_PRESS_START\";\nvar RESPONDER_INACTIVE_PRESS_START = \"RESPONDER_INACTIVE_PRESS_START\";\nvar RESPONDER_GRANT = \"RESPONDER_GRANT\";\nvar RESPONDER_RELEASE = \"RESPONDER_RELEASE\";\nvar RESPONDER_TERMINATED = \"RESPONDER_TERMINATED\";\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\nvar isActiveSignal = function isActiveSignal(signal) {\n  return signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\nvar isButtonRole = function isButtonRole(element) {\n  return element.getAttribute(\"role\") === \"button\";\n};\nvar isPressStartSignal = function isPressStartSignal(signal) {\n  return signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\nvar isTerminalSignal = function isTerminalSignal(signal) {\n  return signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n};\nvar isValidKeyPress = function isValidKeyPress(event) {\n  var key = event.key,\n    target = event.target;\n  var role = target.getAttribute(\"role\");\n  var isSpacebar = key === \" \" || key === \"Spacebar\";\n  return key === \"Enter\" || isSpacebar && role === \"button\";\n};\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450;\nvar DEFAULT_PRESS_DELAY_MS = 50;\nvar PressResponder = function () {\n  function PressResponder(config) {\n    _classCallCheck(this, PressResponder);\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n  _createClass(PressResponder, [{\n    key: \"configure\",\n    value: function configure(config) {\n      this._config = config;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._cancelLongPressDelayTimeout();\n      this._cancelPressDelayTimeout();\n      this._cancelPressOutDelayTimeout();\n    }\n  }, {\n    key: \"getEventHandlers\",\n    value: function getEventHandlers() {\n      if (this._eventHandlers == null) {\n        this._eventHandlers = this._createEventHandlers();\n      }\n      return this._eventHandlers;\n    }\n  }, {\n    key: \"_createEventHandlers\",\n    value: function _createEventHandlers() {\n      var _this = this;\n      var start = function start(event, shouldDelay) {\n        event.persist();\n        _this._cancelPressOutDelayTimeout();\n        _this._longPressDispatched = false;\n        _this._selectionTerminated = false;\n        _this._touchState = NOT_RESPONDER;\n        _this._isPointerTouch = event.nativeEvent.type === \"touchstart\";\n        _this._receiveSignal(RESPONDER_GRANT, event);\n        var delayPressStart = normalizeDelay(_this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n        if (shouldDelay !== false && delayPressStart > 0) {\n          _this._pressDelayTimeout = setTimeout(function () {\n            _this._receiveSignal(DELAY, event);\n          }, delayPressStart);\n        } else {\n          _this._receiveSignal(DELAY, event);\n        }\n        var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n        _this._longPressDelayTimeout = setTimeout(function () {\n          _this._handleLongPress(event);\n        }, delayLongPress + delayPressStart);\n      };\n      var end = function end(event) {\n        _this._receiveSignal(RESPONDER_RELEASE, event);\n      };\n      var keyupHandler = function keyupHandler(event) {\n        var onPress = _this._config.onPress;\n        var target = event.target;\n        if (_this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n          end(event);\n          document.removeEventListener(\"keyup\", keyupHandler);\n          var role = target.getAttribute(\"role\");\n          var elementType = target.tagName.toLowerCase();\n          var isNativeInteractiveElement = role === \"link\" || elementType === \"a\" || elementType === \"button\" || elementType === \"input\" || elementType === \"select\" || elementType === \"textarea\";\n          if (onPress != null && !isNativeInteractiveElement) {\n            onPress(event);\n          }\n        }\n      };\n      return {\n        onStartShouldSetResponder: function onStartShouldSetResponder(event) {\n          var disabled = _this._config.disabled;\n          if (disabled && isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n          if (disabled == null) {\n            return true;\n          }\n          return !disabled;\n        },\n        onKeyDown: function onKeyDown(event) {\n          var disabled = _this._config.disabled;\n          var key = event.key,\n            target = event.target;\n          if (!disabled && isValidKeyPress(event)) {\n            if (_this._touchState === NOT_RESPONDER) {\n              start(event, false);\n              document.addEventListener(\"keyup\", keyupHandler);\n            }\n            var role = target.getAttribute(\"role\");\n            var isSpacebarKey = key === \" \" || key === \"Spacebar\";\n            var _isButtonRole = role === \"button\" || role === \"menuitem\";\n            if (isSpacebarKey && _isButtonRole) {\n              event.preventDefault();\n            }\n            event.stopPropagation();\n          }\n        },\n        onResponderGrant: function onResponderGrant(event) {\n          return start(event);\n        },\n        onResponderMove: function onResponderMove(event) {\n          if (_this._config.onPressMove != null) {\n            _this._config.onPressMove(event);\n          }\n          var touch = getTouchFromResponderEvent(event);\n          if (_this._touchActivatePosition != null) {\n            var deltaX = _this._touchActivatePosition.pageX - touch.pageX;\n            var deltaY = _this._touchActivatePosition.pageY - touch.pageY;\n            if (Math.hypot(deltaX, deltaY) > 10) {\n              _this._cancelLongPressDelayTimeout();\n            }\n          }\n        },\n        onResponderRelease: function onResponderRelease(event) {\n          return end(event);\n        },\n        onResponderTerminate: function onResponderTerminate(event) {\n          if (event.nativeEvent.type === \"selectionchange\") {\n            _this._selectionTerminated = true;\n          }\n          _this._receiveSignal(RESPONDER_TERMINATED, event);\n        },\n        onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n          var _this$_config = _this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress;\n          if (!disabled && onLongPress != null && _this._isPointerTouch && event.nativeEvent.type === \"contextmenu\") {\n            return false;\n          }\n          if (cancelable == null) {\n            return true;\n          }\n          return cancelable;\n        },\n        onClick: function onClick(event) {\n          var _this$_config2 = _this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n          if (!disabled) {\n            event.stopPropagation();\n            if (_this._longPressDispatched || _this._selectionTerminated) {\n              event.preventDefault();\n            } else if (onPress != null && event.altKey === false) {\n              onPress(event);\n            }\n          } else {\n            if (isButtonRole(event.currentTarget)) {\n              event.stopPropagation();\n            }\n          }\n        },\n        onContextMenu: function onContextMenu(event) {\n          var _this$_config3 = _this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n          if (!disabled) {\n            if (onLongPress != null && _this._isPointerTouch && !event.defaultPrevented) {\n              event.preventDefault();\n              event.stopPropagation();\n            }\n          } else {\n            if (isButtonRole(event.currentTarget)) {\n              event.stopPropagation();\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"_receiveSignal\",\n    value: function _receiveSignal(signal, event) {\n      var prevState = this._touchState;\n      var nextState = null;\n      if (Transitions[prevState] != null) {\n        nextState = Transitions[prevState][signal];\n      }\n      if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n        return;\n      }\n      if (nextState == null || nextState === ERROR) {\n        console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n      } else if (prevState !== nextState) {\n        this._performTransitionSideEffects(prevState, nextState, signal, event);\n        this._touchState = nextState;\n      }\n    }\n  }, {\n    key: \"_performTransitionSideEffects\",\n    value: function _performTransitionSideEffects(prevState, nextState, signal, event) {\n      var _this2 = this;\n      if (isTerminalSignal(signal)) {\n        setTimeout(function () {\n          _this2._isPointerTouch = false;\n        }, 0);\n        this._touchActivatePosition = null;\n        this._cancelLongPressDelayTimeout();\n      }\n      if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n        var onLongPress = this._config.onLongPress;\n        if (onLongPress != null && event.nativeEvent.key == null) {\n          onLongPress(event);\n          this._longPressDispatched = true;\n        }\n      }\n      var isPrevActive = isActiveSignal(prevState);\n      var isNextActive = isActiveSignal(nextState);\n      if (!isPrevActive && isNextActive) {\n        this._activate(event);\n      } else if (isPrevActive && !isNextActive) {\n        this._deactivate(event);\n      }\n      if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n        var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n        if (onPress != null) {\n          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n          if (!isPressCanceledByLongPress) {\n            if (!isNextActive && !isPrevActive) {\n              this._activate(event);\n              this._deactivate(event);\n            }\n          }\n        }\n      }\n      this._cancelPressDelayTimeout();\n    }\n  }, {\n    key: \"_activate\",\n    value: function _activate(event) {\n      var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n      var touch = getTouchFromResponderEvent(event);\n      this._touchActivatePosition = {\n        pageX: touch.pageX,\n        pageY: touch.pageY\n      };\n      if (onPressStart != null) {\n        onPressStart(event);\n      }\n      if (onPressChange != null) {\n        onPressChange(true);\n      }\n    }\n  }, {\n    key: \"_deactivate\",\n    value: function _deactivate(event) {\n      var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n      function end() {\n        if (onPressEnd != null) {\n          onPressEnd(event);\n        }\n        if (onPressChange != null) {\n          onPressChange(false);\n        }\n      }\n      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n      if (delayPressEnd > 0) {\n        this._pressOutDelayTimeout = setTimeout(function () {\n          end();\n        }, delayPressEnd);\n      } else {\n        end();\n      }\n    }\n  }, {\n    key: \"_handleLongPress\",\n    value: function _handleLongPress(event) {\n      if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n        this._receiveSignal(LONG_PRESS_DETECTED, event);\n      }\n    }\n  }, {\n    key: \"_cancelLongPressDelayTimeout\",\n    value: function _cancelLongPressDelayTimeout() {\n      if (this._longPressDelayTimeout != null) {\n        clearTimeout(this._longPressDelayTimeout);\n        this._longPressDelayTimeout = null;\n      }\n    }\n  }, {\n    key: \"_cancelPressDelayTimeout\",\n    value: function _cancelPressDelayTimeout() {\n      if (this._pressDelayTimeout != null) {\n        clearTimeout(this._pressDelayTimeout);\n        this._pressDelayTimeout = null;\n      }\n    }\n  }, {\n    key: \"_cancelPressOutDelayTimeout\",\n    value: function _cancelPressOutDelayTimeout() {\n      if (this._pressOutDelayTimeout != null) {\n        clearTimeout(this._pressOutDelayTimeout);\n        this._pressOutDelayTimeout = null;\n      }\n    }\n  }]);\n  return PressResponder;\n}();\nexports.default = PressResponder;\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n    changedTouches = _event$nativeEvent.changedTouches,\n    touches = _event$nativeEvent.touches;\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n  return event.nativeEvent;\n}\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/cjs/modules/usePressEvents/PressResponder.js"],"names":["exports","__esModule","default","DELAY","ERROR","LONG_PRESS_DETECTED","NOT_RESPONDER","RESPONDER_ACTIVE_LONG_PRESS_START","RESPONDER_ACTIVE_PRESS_START","RESPONDER_INACTIVE_PRESS_START","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","Transitions","Object","freeze","isActiveSignal","signal","isButtonRole","element","getAttribute","isPressStartSignal","isTerminalSignal","isValidKeyPress","event","key","target","role","isSpacebar","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_DELAY_MS","PressResponder","constructor","config","_eventHandlers","_isPointerTouch","_longPressDelayTimeout","_longPressDispatched","_pressDelayTimeout","_pressOutDelayTimeout","_touchState","configure","_config","reset","_cancelLongPressDelayTimeout","_cancelPressDelayTimeout","_cancelPressOutDelayTimeout","getEventHandlers","_createEventHandlers","start","shouldDelay","persist","_selectionTerminated","nativeEvent","type","_receiveSignal","delayPressStart","normalizeDelay","setTimeout","delayLongPress","_handleLongPress","end","keyupHandler","onPress","document","removeEventListener","elementType","tagName","toLowerCase","isNativeInteractiveElement","onStartShouldSetResponder","disabled","currentTarget","stopPropagation","onKeyDown","addEventListener","isSpacebarKey","_isButtonRole","preventDefault","onResponderGrant","onResponderMove","onPressMove","touch","getTouchFromResponderEvent","_touchActivatePosition","deltaX","pageX","deltaY","pageY","Math","hypot","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","_this$_config","cancelable","onLongPress","onClick","_this$_config2","altKey","onContextMenu","_this$_config3","defaultPrevented","prevState","nextState","console","error","_performTransitionSideEffects","isPrevActive","isNextActive","_activate","_deactivate","_this$_config4","_onLongPress","isPressCanceledByLongPress","_this$_config5","onPressChange","onPressStart","_this$_config6","onPressEnd","delayPressEnd","clearTimeout","delay","min","fallback","max","_event$nativeEvent","changedTouches","touches","length","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isButtonRole = element => element.getAttribute('role') === 'button';\n\nvar isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n\nvar isValidKeyPress = event => {\n  var key = event.key,\n      target = event.target;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return key === 'Enter' || isSpacebar && role === 'button';\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nclass PressResponder {\n  constructor(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n\n\n  reset() {\n    this._cancelLongPressDelayTimeout();\n\n    this._cancelPressDelayTimeout();\n\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n\n\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n\n    return this._eventHandlers;\n  }\n\n  _createEventHandlers() {\n    var start = (event, shouldDelay) => {\n      event.persist();\n\n      this._cancelPressOutDelayTimeout();\n\n      this._longPressDispatched = false;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      this._receiveSignal(RESPONDER_GRANT, event);\n\n      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n\n      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    var end = event => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    var keyupHandler = event => {\n      var onPress = this._config.onPress;\n      var target = event.target;\n\n      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n        var role = target.getAttribute('role');\n        var elementType = target.tagName.toLowerCase();\n        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';\n\n        if (onPress != null && !isNativeInteractiveElement) {\n          onPress(event);\n        }\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: event => {\n        var disabled = this._config.disabled;\n\n        if (disabled && isButtonRole(event.currentTarget)) {\n          event.stopPropagation();\n        }\n\n        if (disabled == null) {\n          return true;\n        }\n\n        return !disabled;\n      },\n      onKeyDown: event => {\n        var disabled = this._config.disabled;\n        var key = event.key,\n            target = event.target;\n\n        if (!disabled && isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n\n          var role = target.getAttribute('role');\n          var isSpacebarKey = key === ' ' || key === 'Spacebar';\n\n          var _isButtonRole = role === 'button' || role === 'menuitem';\n\n          if (isSpacebarKey && _isButtonRole) {\n            // Prevent spacebar scrolling the window\n            event.preventDefault();\n          }\n\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: event => start(event),\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n\n        var touch = getTouchFromResponderEvent(event);\n\n        if (this._touchActivatePosition != null) {\n          var deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = this._touchActivatePosition.pageY - touch.pageY;\n\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: event => end(event),\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: event => {\n        var _this$_config = this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n\n        if (cancelable == null) {\n          return true;\n        }\n\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: event => {\n        var _this$_config2 = this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          event.stopPropagation();\n\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.altKey === false) {\n            onPress(event);\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: event => {\n        var _this$_config3 = this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n\n        if (!disabled) {\n          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n\n\n  _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n\n    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n\n\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      // Pressable suppression of contextmenu on windows.\n      // On Windows, the contextmenu is displayed after pointerup.\n      // https://github.com/necolas/react-native-web/issues/2296\n      setTimeout(() => {\n        this._isPointerTouch = false;\n      }, 0);\n      this._touchActivatePosition = null;\n\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  }\n\n  _activate(event) {\n    var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n\n  _deactivate(event) {\n    var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n\n  _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n\n}\n\nexports.default = PressResponder;\n\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}\n\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}