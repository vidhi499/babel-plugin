{"ast":null,"code":"'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\nexport function elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n        if (kk === offsets.length - 1) {\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\nexport function newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\nexport function computeWindowedRenderLimits(data, getItemCount, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  var offset = scrollMetrics.offset,\n    velocity = scrollMetrics.velocity,\n    visibleLength = scrollMetrics.visibleLength;\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n  var leadFactor = 0.5;\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], itemCount, getFrameMetricsApprox),\n    overscanFirst = _elementsThatOverlapO[0],\n    first = _elementsThatOverlapO[1],\n    last = _elementsThatOverlapO[2],\n    overscanLast = _elementsThatOverlapO[3];\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  };\n  var newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n  return {\n    first: first,\n    last: last\n  };\n}\nexport function keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n  return String(index);\n}\n;\n;\n(function () {\n  var _a, _b;\n  if (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n    var currentExports = __webpack_module__.exports;\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      });\n      import.meta.webpackHot.accept();\n      if (prevExports !== null) {\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      var isNoLongerABoundary = prevExports !== null;\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js"],"names":["invariant","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","data","getItemCount","maxToRenderPerBatch","windowSize","getFrameMetricsApprox","scrollMetrics","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","keyExtractor","item","index","key","id","String"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\n\nexport function elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\nexport function newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\nexport function computeWindowedRenderLimits(data, getItemCount, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], itemCount, getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first,\n    last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first,\n      last,\n      itemCount,\n      overscanFirst,\n      overscanLast,\n      visible\n    }));\n  }\n\n  return {\n    first,\n    last\n  };\n}\nexport function keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n\n  return String(index);\n}"]},"metadata":{},"sourceType":"module"}