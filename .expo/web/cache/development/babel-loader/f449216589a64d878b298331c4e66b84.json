{"ast":null,"code":"var slice = Array.prototype.slice;\nexport default function createOrderedCSSStyleSheet(sheet) {\n  var groups = {};\n  var selectors = {};\n  if (sheet != null) {\n    var group;\n    slice.call(sheet.cssRules).forEach(function (cssRule, i) {\n      var cssText = cssRule.cssText;\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = {\n          start: i,\n          rules: [cssText]\n        };\n      } else {\n        var selectorText = getSelectorText(cssText);\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n  function sheetInsert(sheet, group, text) {\n    var orderedGroups = getOrderedGroups(groups);\n    var groupIndex = orderedGroups.indexOf(group);\n    var nextGroupIndex = groupIndex + 1;\n    var nextGroup = orderedGroups[nextGroupIndex];\n    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;\n    var isInserted = insertRuleAt(sheet, text, position);\n    if (isInserted) {\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      }\n      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        var groupNumber = orderedGroups[i];\n        var previousStart = groups[groupNumber].start || 0;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n    return isInserted;\n  }\n  var OrderedCSSStyleSheet = {\n    getTextContent: function getTextContent() {\n      return getOrderedGroups(groups).map(function (group) {\n        var rules = groups[group].rules;\n        var marker = rules.shift();\n        rules.sort();\n        rules.unshift(marker);\n        return rules.join('\\n');\n      }).join('\\n');\n    },\n    insert: function insert(cssText, groupValue) {\n      var group = Number(groupValue);\n      if (groups[group] == null) {\n        var markerRule = encodeGroupRule(group);\n        groups[group] = {\n          start: null,\n          rules: [markerRule]\n        };\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      }\n      var selectorText = getSelectorText(cssText);\n      if (selectorText != null && selectors[selectorText] == null) {\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText);\n        if (sheet != null) {\n          var isInserted = sheetInsert(sheet, group, cssText);\n          if (!isInserted) {\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n  return OrderedCSSStyleSheet;\n}\nfunction encodeGroupRule(group) {\n  return \"[stylesheet-group=\\\"\" + group + \"\\\"]{}\";\n}\nvar groupPattern = /[\"']/g;\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(groupPattern)[1]);\n}\nfunction getOrderedGroups(obj) {\n  return Object.keys(obj).map(Number).sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n}\nvar selectorPattern = /\\s*([,])\\s*/g;\nfunction getSelectorText(cssText) {\n  var selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(selectorPattern, '$1') : null;\n}\nfunction insertRuleAt(root, cssText, position) {\n  try {\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n;\n;\n(function () {\n  var _a, _b;\n  if (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n    var currentExports = __webpack_module__.exports;\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      });\n      import.meta.webpackHot.accept();\n      if (prevExports !== null) {\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      var isNoLongerABoundary = prevExports !== null;\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/exports/StyleSheet/dom/createOrderedCSSStyleSheet.js"],"names":["slice","Array","prototype","createOrderedCSSStyleSheet","sheet","groups","selectors","group","call","cssRules","forEach","cssRule","i","cssText","indexOf","decodeGroupRule","start","rules","selectorText","getSelectorText","push","sheetInsert","text","orderedGroups","getOrderedGroups","groupIndex","nextGroupIndex","nextGroup","position","length","isInserted","insertRuleAt","groupNumber","previousStart","OrderedCSSStyleSheet","getTextContent","map","marker","shift","sort","unshift","join","insert","groupValue","Number","markerRule","encodeGroupRule","pop","groupPattern","split","obj","Object","keys","a","b","selectorPattern","selector","trim","replace","root","insertRule","e"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar slice = Array.prototype.slice;\n/**\n * Order-based insertion of CSS.\n *\n * Each rule is associated with a numerically defined group.\n * Groups are ordered within the style sheet according to their number, with the\n * lowest first.\n *\n * Groups are implemented using marker rules. The selector of the first rule of\n * each group is used only to encode the group number for hydration. An\n * alternative implementation could rely on CSSMediaRule, allowing groups to be\n * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is\n * broken.\n * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule\n * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674\n */\n\nexport default function createOrderedCSSStyleSheet(sheet) {\n  var groups = {};\n  var selectors = {};\n  /**\n   * Hydrate approximate record from any existing rules in the sheet.\n   */\n\n  if (sheet != null) {\n    var group;\n    slice.call(sheet.cssRules).forEach((cssRule, i) => {\n      var cssText = cssRule.cssText; // Create record of existing selectors and rules\n\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = {\n          start: i,\n          rules: [cssText]\n        };\n      } else {\n        var selectorText = getSelectorText(cssText);\n\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n\n  function sheetInsert(sheet, group, text) {\n    var orderedGroups = getOrderedGroups(groups);\n    var groupIndex = orderedGroups.indexOf(group);\n    var nextGroupIndex = groupIndex + 1;\n    var nextGroup = orderedGroups[nextGroupIndex]; // Insert rule before the next group, or at the end of the stylesheet\n\n    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;\n    var isInserted = insertRuleAt(sheet, text, position);\n\n    if (isInserted) {\n      // Set the starting index of the new group\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      } // Increment the starting index of all subsequent groups\n\n\n      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        var groupNumber = orderedGroups[i];\n        var previousStart = groups[groupNumber].start || 0;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n\n    return isInserted;\n  }\n\n  var OrderedCSSStyleSheet = {\n    /**\n     * The textContent of the style sheet.\n     */\n    getTextContent() {\n      return getOrderedGroups(groups).map(group => {\n        var rules = groups[group].rules; // Sorting provides deterministic order of styles in group for\n        // build-time extraction of the style sheet.\n\n        var marker = rules.shift();\n        rules.sort();\n        rules.unshift(marker);\n        return rules.join('\\n');\n      }).join('\\n');\n    },\n\n    /**\n     * Insert a rule into the style sheet\n     */\n    insert(cssText, groupValue) {\n      var group = Number(groupValue); // Create a new group.\n\n      if (groups[group] == null) {\n        var markerRule = encodeGroupRule(group); // Create the internal record.\n\n        groups[group] = {\n          start: null,\n          rules: [markerRule]\n        }; // Update CSSOM.\n\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      } // selectorText is more reliable than cssText for insertion checks. The\n      // browser excludes vendor-prefixed properties and rewrites certain values\n      // making cssText more likely to be different from what was inserted.\n\n\n      var selectorText = getSelectorText(cssText);\n\n      if (selectorText != null && selectors[selectorText] == null) {\n        // Update the internal records.\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText); // Update CSSOM.\n\n        if (sheet != null) {\n          var isInserted = sheetInsert(sheet, group, cssText);\n\n          if (!isInserted) {\n            // Revert internal record change if a rule was rejected (e.g.,\n            // unrecognized pseudo-selector)\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n\n  };\n  return OrderedCSSStyleSheet;\n}\n/**\n * Helper functions\n */\n\nfunction encodeGroupRule(group) {\n  return \"[stylesheet-group=\\\"\" + group + \"\\\"]{}\";\n}\n\nvar groupPattern = /[\"']/g;\n\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(groupPattern)[1]);\n}\n\nfunction getOrderedGroups(obj) {\n  return Object.keys(obj).map(Number).sort((a, b) => a > b ? 1 : -1);\n}\n\nvar selectorPattern = /\\s*([,])\\s*/g;\n\nfunction getSelectorText(cssText) {\n  var selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(selectorPattern, '$1') : null;\n}\n\nfunction insertRuleAt(root, cssText, position) {\n  try {\n    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    // JSDOM doesn't support `CSSSMediaRule#insertRule`.\n    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.\n    return false;\n  }\n}"]},"metadata":{},"sourceType":"module"}