{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nexports.__esModule = true;\nexports.default = void 0;\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar Info = _createClass(function Info() {\n  _classCallCheck(this, Info);\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n});\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\nvar _sampleRate = DEBUG ? 1 : null;\nvar FillRateHelper = function () {\n  function FillRateHelper(getFrameMetrics) {\n    _classCallCheck(this, FillRateHelper);\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n  _createClass(FillRateHelper, [{\n    key: \"activate\",\n    value: function activate() {\n      if (this._enabled && this._samplesStartTime == null) {\n        DEBUG && console.debug(\"FillRateHelper: activate\");\n        this._samplesStartTime = global.performance.now();\n      }\n    }\n  }, {\n    key: \"deactivateAndFlush\",\n    value: function deactivateAndFlush() {\n      if (!this._enabled) {\n        return;\n      }\n      var start = this._samplesStartTime;\n      if (start == null) {\n        DEBUG && console.debug(\"FillRateHelper: bail on deactivate with no start time\");\n        return;\n      }\n      if (this._info.sample_count < _minSampleCount) {\n        this._resetData();\n        return;\n      }\n      var total_time_spent = global.performance.now() - start;\n      var info = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._info), {}, {\n        total_time_spent: total_time_spent\n      });\n      if (DEBUG) {\n        var derived = {\n          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n        };\n        for (var key in derived) {\n          derived[key] = Math.round(1000 * derived[key]) / 1000;\n        }\n        console.debug(\"FillRateHelper deactivateAndFlush: \", {\n          derived: derived,\n          info: info\n        });\n      }\n      _listeners.forEach(function (listener) {\n        return listener(info);\n      });\n      this._resetData();\n    }\n  }, {\n    key: \"computeBlankness\",\n    value: function computeBlankness(props, state, scrollMetrics) {\n      if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n        return 0;\n      }\n      var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength;\n      this._info.sample_count++;\n      this._info.pixels_sampled += Math.round(visibleLength);\n      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n      var scrollSpeed = Math.round(Math.abs(velocity) * 1000);\n      var now = global.performance.now();\n      if (this._anyBlankStartTime != null) {\n        this._info.any_blank_ms += now - this._anyBlankStartTime;\n      }\n      this._anyBlankStartTime = null;\n      if (this._mostlyBlankStartTime != null) {\n        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n      }\n      this._mostlyBlankStartTime = null;\n      var blankTop = 0;\n      var first = state.first;\n      var firstFrame = this._getFrameMetrics(first);\n      while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n        firstFrame = this._getFrameMetrics(first);\n        first++;\n      }\n      if (firstFrame && first > 0) {\n        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n      }\n      var blankBottom = 0;\n      var last = state.last;\n      var lastFrame = this._getFrameMetrics(last);\n      while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n        lastFrame = this._getFrameMetrics(last);\n        last--;\n      }\n      if (lastFrame && last < props.getItemCount(props.data) - 1) {\n        var bottomEdge = lastFrame.offset + lastFrame.length;\n        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n      }\n      var pixels_blank = Math.round(blankTop + blankBottom);\n      var blankness = pixels_blank / visibleLength;\n      if (blankness > 0) {\n        this._anyBlankStartTime = now;\n        this._info.any_blank_speed_sum += scrollSpeed;\n        this._info.any_blank_count++;\n        this._info.pixels_blank += pixels_blank;\n        if (blankness > 0.5) {\n          this._mostlyBlankStartTime = now;\n          this._info.mostly_blank_count++;\n        }\n      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n        this.deactivateAndFlush();\n      }\n      return blankness;\n    }\n  }, {\n    key: \"enabled\",\n    value: function enabled() {\n      return this._enabled;\n    }\n  }, {\n    key: \"_resetData\",\n    value: function _resetData() {\n      this._anyBlankStartTime = null;\n      this._info = new Info();\n      this._mostlyBlankStartTime = null;\n      this._samplesStartTime = null;\n    }\n  }], [{\n    key: \"addListener\",\n    value: function addListener(callback) {\n      if (_sampleRate === null) {\n        console.warn(\"Call `FillRateHelper.setSampleRate` before `addListener`.\");\n      }\n      _listeners.push(callback);\n      return {\n        remove: function remove() {\n          _listeners = _listeners.filter(function (listener) {\n            return callback !== listener;\n          });\n        }\n      };\n    }\n  }, {\n    key: \"setSampleRate\",\n    value: function setSampleRate(sampleRate) {\n      _sampleRate = sampleRate;\n    }\n  }, {\n    key: \"setMinSampleCount\",\n    value: function setMinSampleCount(minSampleCount) {\n      _minSampleCount = minSampleCount;\n    }\n  }]);\n  return FillRateHelper;\n}();\nvar _default = FillRateHelper;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/cjs/vendor/react-native/FillRateHelper/index.js"],"names":["_interopRequireDefault","require","default","exports","__esModule","_objectSpread2","Info","constructor","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","callback","console","warn","push","remove","filter","listener","sampleRate","minSampleCount","getFrameMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_getFrameMetrics","Math","random","_resetData","activate","debug","global","performance","now","deactivateAndFlush","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","key","round","forEach","computeBlankness","props","state","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","blankTop","first","firstFrame","last","inLayout","min","max","blankBottom","lastFrame","bottomEdge","length","blankness","enabled","_default","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nclass Info {\n  constructor() {\n    this.any_blank_count = 0;\n    this.any_blank_ms = 0;\n    this.any_blank_speed_sum = 0;\n    this.mostly_blank_count = 0;\n    this.mostly_blank_ms = 0;\n    this.pixels_blank = 0;\n    this.pixels_sampled = 0;\n    this.pixels_scrolled = 0;\n    this.total_time_spent = 0;\n    this.sample_count = 0;\n  }\n\n}\n\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\n\n\nclass FillRateHelper {\n  static addListener(callback) {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n\n    _listeners.push(callback);\n\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      }\n    };\n  }\n\n  static setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n\n    var start = this._samplesStartTime; // const for flow\n\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n\n      return;\n    }\n\n    var total_time_spent = global.performance.now() - start;\n    var info = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._info), {}, {\n      total_time_spent\n    });\n\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n\n      for (var key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived,\n        info\n      });\n    }\n\n    _listeners.forEach(listener => listener(info));\n\n    this._resetData();\n  }\n\n  computeBlankness(props, state, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n      return 0;\n    }\n\n    var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n    var now = global.performance.now();\n\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n\n    this._anyBlankStartTime = null;\n\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = state.first;\n\n    var firstFrame = this._getFrameMetrics(first);\n\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n\n\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n\n    var blankBottom = 0;\n    var last = state.last;\n\n    var lastFrame = this._getFrameMetrics(last);\n\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n\n\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n\n    return blankness;\n  }\n\n  enabled() {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n\n}\n\nvar _default = FillRateHelper;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}