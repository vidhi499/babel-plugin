{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nexports.__esModule = true;\nexports.ResponderTouchHistoryStore = void 0;\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\nvar __DEV__ = \"development\" !== \"production\";\nvar MAX_TOUCH_BANK = 20;\nfunction timestampForTouch(touch) {\n  return touch.timeStamp || touch.timestamp;\n}\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n  if (identifier == null) {\n    console.error(\"Touch object is missing identifier.\");\n  }\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error(\"Touch identifier %s is greater than maximum supported %s which causes \" + \"performance issues backfilling array locations for all of the indices.\", identifier, MAX_TOUCH_BANK);\n    }\n  }\n  return identifier;\n}\nfunction recordTouchStart(touch, touchHistory) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchHistory.touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\nfunction recordTouchMove(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn(\"Cannot record touch move without a touch start.\\n\", \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\nfunction recordTouchEnd(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn(\"Cannot record touch end without a touch start.\\n\", \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\nfunction printTouchBank(touchHistory) {\n  var touchBank = touchHistory.touchBank;\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\nvar ResponderTouchHistoryStore = function () {\n  function ResponderTouchHistoryStore() {\n    _classCallCheck(this, ResponderTouchHistoryStore);\n    this._touchHistory = {\n      touchBank: [],\n      numberActiveTouches: 0,\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n  }\n  _createClass(ResponderTouchHistoryStore, [{\n    key: \"recordTouchTrack\",\n    value: function recordTouchTrack(topLevelType, nativeEvent) {\n      var touchHistory = this._touchHistory;\n      if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {\n        nativeEvent.changedTouches.forEach(function (touch) {\n          return recordTouchMove(touch, touchHistory);\n        });\n      } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {\n        nativeEvent.changedTouches.forEach(function (touch) {\n          return recordTouchStart(touch, touchHistory);\n        });\n        touchHistory.numberActiveTouches = nativeEvent.touches.length;\n        if (touchHistory.numberActiveTouches === 1) {\n          touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n        }\n      } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {\n        nativeEvent.changedTouches.forEach(function (touch) {\n          return recordTouchEnd(touch, touchHistory);\n        });\n        touchHistory.numberActiveTouches = nativeEvent.touches.length;\n        if (touchHistory.numberActiveTouches === 1) {\n          var touchBank = touchHistory.touchBank;\n          for (var i = 0; i < touchBank.length; i++) {\n            var touchTrackToCheck = touchBank[i];\n            if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n              touchHistory.indexOfSingleActiveTouch = i;\n              break;\n            }\n          }\n          if (__DEV__) {\n            var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n            if (!(activeRecord != null && activeRecord.touchActive)) {\n              console.error(\"Cannot find single active touch.\");\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"touchHistory\",\n    get: function get() {\n      return this._touchHistory;\n    }\n  }]);\n  return ResponderTouchHistoryStore;\n}();\nexports.ResponderTouchHistoryStore = ResponderTouchHistoryStore;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/cjs/modules/useResponderEvents/ResponderTouchHistoryStore.js"],"names":["exports","__esModule","ResponderTouchHistoryStore","_ResponderEventTypes","require","__DEV__","process","MAX_TOUCH_BANK","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","console","error","recordTouchStart","touchHistory","touchBank","mostRecentTimeStamp","recordTouchMove","warn","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","constructor","_touchHistory","numberActiveTouches","indexOfSingleActiveTouch","recordTouchTrack","topLevelType","nativeEvent","isMoveish","changedTouches","forEach","isStartish","touches","isEndish","i","touchTrackToCheck","activeRecord"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.ResponderTouchHistoryStore = void 0;\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch, touchHistory) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchHistory.touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\n\nfunction recordTouchEnd(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank(touchHistory) {\n  var touchBank = touchHistory.touchBank;\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nclass ResponderTouchHistoryStore {\n  constructor() {\n    this._touchHistory = {\n      touchBank: [],\n      //Array<TouchRecord>\n      numberActiveTouches: 0,\n      // If there is only one active touch, we remember its location. This prevents\n      // us having to loop through all of the touches all the time in the most\n      // common case.\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n  }\n\n  recordTouchTrack(topLevelType, nativeEvent) {\n    var touchHistory = this._touchHistory;\n\n    if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));\n    } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        var touchBank = touchHistory.touchBank;\n\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  }\n\n  get touchHistory() {\n    return this._touchHistory;\n  }\n\n}\n\nexports.ResponderTouchHistoryStore = ResponderTouchHistoryStore;"]},"metadata":{},"sourceType":"script"}