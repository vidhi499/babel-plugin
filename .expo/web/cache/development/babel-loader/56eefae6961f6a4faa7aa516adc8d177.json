{"ast":null,"code":"import createResponderEvent from \"./createResponderEvent\";\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from \"./ResponderEventTypes\";\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from \"./utils\";\nimport { ResponderTouchHistoryStore } from \"./ResponderTouchHistoryStore\";\nimport canUseDOM from \"../canUseDom\";\nvar emptyObject = {};\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nvar responderTouchHistoryStore = new ResponderTouchHistoryStore();\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  if (eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n      id = _currentResponder.id,\n      node = _currentResponder.node;\n    var _getResponderConfig = getResponderConfig(id),\n      onResponderStart = _getResponderConfig.onResponderStart,\n      onResponderMove = _getResponderConfig.onResponderMove,\n      onResponderEnd = _getResponderConfig.onResponderEnd,\n      onResponderRelease = _getResponderConfig.onResponderRelease,\n      onResponderTerminate = _getResponderConfig.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = isCancelish(eventType) || eventType === 'contextmenu' || eventType === 'blur' && eventTarget === window || eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || isScrollEvent && trackedTouchCount === 0 || isScrollEvent && eventTarget.contains(node) && eventTarget !== node || isSelectionChangeEvent && hasValidSelection(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n      nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id: id,\n            node: node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n        if (_result != null) {\n          return _result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n    currentId = _currentResponder2.id,\n    currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n    node = wantsResponder.node;\n  var _getResponderConfig2 = getResponderConfig(id),\n    onResponderGrant = _getResponderConfig2.onResponderGrant,\n    onResponderReject = _getResponderConfig2.onResponderReject;\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  } else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n    var allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = ['mousedown', 'mousemove', 'mouseup', 'dragstart', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap[\"delete\"](id);\n  }\n}\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n    id = _currentResponder3.id,\n    node = _currentResponder3.node;\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n      onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\nexport function getResponderNode() {\n  return currentResponder.node;\n}\n;\n;\n(function () {\n  var _a, _b;\n  if (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n    var currentExports = __webpack_module__.exports;\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      });\n      import.meta.webpackHot.accept();\n      if (prevExports !== null) {\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      var isNoLongerABoundary = prevExports !== null;\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js"],"names":["createResponderEvent","isCancelish","isEndish","isMoveish","isScroll","isSelectionChange","isStartish","getLowestCommonAncestor","getResponderPaths","hasTargetTouches","hasValidSelection","isPrimaryPointerDown","setResponderId","ResponderTouchHistoryStore","canUseDOM","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","responderTouchHistoryStore","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isMoveEvent","isEndEvent","isScrollEvent","isSelectionChangeEvent","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","window","contains","relatedTarget","isReleaseEvent","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","__reactResponderSystemActive","addEventListener","forEach","document","addNode","set","removeNode","terminateResponder","has","_currentResponder3","_getResponderConfig4","event","getResponderNode"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\nimport createResponderEvent from './createResponderEvent';\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from './ResponderEventTypes';\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from './utils';\nimport { ResponderTouchHistoryStore } from './ResponderTouchHistoryStore';\nimport canUseDOM from '../canUseDom';\n/* ------------ TYPES ------------ */\n\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nvar responderTouchHistoryStore = new ResponderTouchHistoryStore();\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = isCancelish(eventType) || // native context menu\n      eventType === 'contextmenu' || // window blur\n      eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n      isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n      isSelectionChangeEvent && hasValidSelection(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches); // End\n\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      } // Release\n\n\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n\n        changeCurrentResponder(emptyResponder);\n      } // Terminate\n\n\n      if (isTerminateEvent) {\n        var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          // Only call this function is it wasn't already called during negotiation.\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n\n        if (shouldSetCallback(responderEvent) === true) {\n          // Start the path from the potential responder\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id,\n            node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n        onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n    var allowTransfer = true;\n\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      } // Grant next responder\n\n\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\nexport function getResponderNode() {\n  return currentResponder.node;\n}"]},"metadata":{},"sourceType":"module"}