{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar dataUriPattern = /^data:/;\nexport var ImageUriCache = function () {\n  function ImageUriCache() {\n    _classCallCheck(this, ImageUriCache);\n  }\n  _createClass(ImageUriCache, null, [{\n    key: \"has\",\n    value: function has(uri) {\n      var entries = ImageUriCache._entries;\n      var isDataUri = dataUriPattern.test(uri);\n      return isDataUri || Boolean(entries[uri]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(uri) {\n      var entries = ImageUriCache._entries;\n      var lastUsedTimestamp = Date.now();\n      if (entries[uri]) {\n        entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n        entries[uri].refCount += 1;\n      } else {\n        entries[uri] = {\n          lastUsedTimestamp: lastUsedTimestamp,\n          refCount: 1\n        };\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(uri) {\n      var entries = ImageUriCache._entries;\n      if (entries[uri]) {\n        entries[uri].refCount -= 1;\n      }\n      ImageUriCache._cleanUpIfNeeded();\n    }\n  }, {\n    key: \"_cleanUpIfNeeded\",\n    value: function _cleanUpIfNeeded() {\n      var entries = ImageUriCache._entries;\n      var imageUris = Object.keys(entries);\n      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n        var leastRecentlyUsedKey;\n        var leastRecentlyUsedEntry;\n        imageUris.forEach(function (uri) {\n          var entry = entries[uri];\n          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n            leastRecentlyUsedKey = uri;\n            leastRecentlyUsedEntry = entry;\n          }\n        });\n        if (leastRecentlyUsedKey) {\n          delete entries[leastRecentlyUsedKey];\n        }\n      }\n    }\n  }]);\n  return ImageUriCache;\n}();\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n    function callback() {\n      var image = requests[\"\" + requestId];\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n          naturalWidth = image.naturalWidth;\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n    image.onload = function (e) {\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n      if (typeof image.decode === 'function') {\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nexport default ImageLoader;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/modules/ImageLoader/index.js"],"names":["dataUriPattern","ImageUriCache","uri","entries","_entries","isDataUri","test","Boolean","lastUsedTimestamp","Date","now","refCount","_cleanUpIfNeeded","imageUris","Object","keys","length","_maximumEntries","leastRecentlyUsedKey","leastRecentlyUsedEntry","forEach","entry","id","requests","ImageLoader","abort","requestId","image","onerror","onload","getSize","success","failure","complete","interval","setInterval","callback","load","errorCallback","naturalHeight","naturalWidth","clearInterval","has","onLoad","onError","window","Image","onDecode","nativeEvent","e","decode","then","setTimeout","src","prefetch","Promise","resolve","reject","add","remove","queryCache","uris","result","u"],"mappings":";;AAQA,IAAIA,cAAc,GAAG,QAArB;AACA,OAAA,IAAaC,aAAb,GAAA,YAAA;EAAA,SAAA,aAAA,GAAA;IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,CAAA;EAAA;EAAA,YAAA,CAAA,aAAA,EAAA,IAAA,EAAA,CAAA;IAAA,GAAA,EAAA,KAAA;IAAA,KAAA,EACE,SAAA,GAAA,CAAWC,GAAX,EAAgB;MACd,IAAIC,OAAO,GAAGF,aAAa,CAACG,QAA5B;MACA,IAAIC,SAAS,GAAGL,cAAc,CAACM,IAAfN,CAAoBE,GAApBF,CAAhB;MACA,OAAOK,SAAS,IAAIE,OAAO,CAACJ,OAAO,CAACD,GAAD,CAAR,CAA3B;IACD;EALH,CAAA,EAAA;IAAA,GAAA,EAAA,KAAA;IAAA,KAAA,EAOE,SAAA,GAAA,CAAWA,GAAX,EAAgB;MACd,IAAIC,OAAO,GAAGF,aAAa,CAACG,QAA5B;MACA,IAAII,iBAAiB,GAAGC,IAAI,CAACC,GAALD,EAAxB;MAEA,IAAIN,OAAO,CAACD,GAAD,CAAX,EAAkB;QAChBC,OAAO,CAACD,GAAD,CAAPC,CAAaK,iBAAbL,GAAiCK,iBAAjCL;QACAA,OAAO,CAACD,GAAD,CAAPC,CAAaQ,QAAbR,IAAyB,CAAzBA;MACD,CAHD,MAGO;QACLA,OAAO,CAACD,GAAD,CAAPC,GAAe;UACbK,iBAAiB,EAAjBA,iBADa;UAEbG,QAAQ,EAAE;QAFG,CAAfR;MAID;IACF;EApBH,CAAA,EAAA;IAAA,GAAA,EAAA,QAAA;IAAA,KAAA,EAsBE,SAAA,MAAA,CAAcD,GAAd,EAAmB;MACjB,IAAIC,OAAO,GAAGF,aAAa,CAACG,QAA5B;MAEA,IAAID,OAAO,CAACD,GAAD,CAAX,EAAkB;QAChBC,OAAO,CAACD,GAAD,CAAPC,CAAaQ,QAAbR,IAAyB,CAAzBA;MACD;MAGDF,aAAa,CAACW,gBAAdX,EAAAA;IACD;EA/BH,CAAA,EAAA;IAAA,GAAA,EAAA,kBAAA;IAAA,KAAA,EAiCE,SAAA,gBAAA,GAA0B;MACxB,IAAIE,OAAO,GAAGF,aAAa,CAACG,QAA5B;MACA,IAAIS,SAAS,GAAGC,MAAM,CAACC,IAAPD,CAAYX,OAAZW,CAAhB;MAEA,IAAID,SAAS,CAACG,MAAVH,GAAmB,CAAnBA,GAAuBZ,aAAa,CAACgB,eAAzC,EAA0D;QACxD,IAAIC,oBAAJ;QACA,IAAIC,sBAAJ;QACAN,SAAS,CAACO,OAAVP,CAAkB,UAAA,GAAG,EAAI;UACvB,IAAIQ,KAAK,GAAGlB,OAAO,CAACD,GAAD,CAAnB;UAEA,IAAI,CAAC,CAACiB,sBAAD,IAA2BE,KAAK,CAACb,iBAANa,GAA0BF,sBAAsB,CAACX,iBAA7E,KAAmGa,KAAK,CAACV,QAANU,KAAmB,CAA1H,EAA6H;YAC3HH,oBAAoB,GAAGhB,GAAvBgB;YACAC,sBAAsB,GAAGE,KAAzBF;UACD;QACF,CAPDN,CAAAA;QASA,IAAIK,oBAAJ,EAA0B;UACxB,OAAOf,OAAO,CAACe,oBAAD,CAAd;QACD;MACF;IACF;EArDH,CAAA,CAAA,CAAA;EAAA,OAAA,aAAA;AAAA,CAAA,EAAA;AAwDAjB,aAAa,CAACgB,eAAdhB,GAAgC,GAAhCA;AACAA,aAAa,CAACG,QAAdH,GAAyB,CAAA,CAAzBA;AACA,IAAIqB,EAAE,GAAG,CAAT;AACA,IAAIC,QAAQ,GAAG,CAAA,CAAf;AACA,IAAIC,WAAW,GAAG;EAChBC,KADgB,EAAA,SAAA,KAAA,CACVC,SADU,EACC;IACf,IAAIC,KAAK,GAAGJ,QAAQ,CAAC,EAAA,GAAKG,SAAN,CAApB;IAEA,IAAIC,KAAJ,EAAW;MACTA,KAAK,CAACC,OAAND,GAAgB,IAAhBA;MACAA,KAAK,CAACE,MAANF,GAAe,IAAfA;MACAA,KAAK,GAAG,IAARA;MACA,OAAOJ,QAAQ,CAAC,EAAA,GAAKG,SAAN,CAAf;IACD;EACF,CAVe;EAYhBI,OAZgB,EAAA,SAAA,OAAA,CAYR5B,GAZQ,EAYH6B,OAZG,EAYMC,OAZN,EAYe;IAC7B,IAAIC,QAAQ,GAAG,KAAf;IACA,IAAIC,QAAQ,GAAGC,WAAW,CAACC,QAAD,EAAW,EAAX,CAA1B;IACA,IAAIV,SAAS,GAAGF,WAAW,CAACa,IAAZb,CAAiBtB,GAAjBsB,EAAsBY,QAAtBZ,EAAgCc,aAAhCd,CAAhB;IAEA,SAASY,QAAT,GAAoB;MAClB,IAAIT,KAAK,GAAGJ,QAAQ,CAAC,EAAA,GAAKG,SAAN,CAApB;MAEA,IAAIC,KAAJ,EAAW;QACT,IAAIY,aAAa,GAAGZ,KAAK,CAACY,aAA1B;UACIC,YAAY,GAAGb,KAAK,CAACa,YADzB;QAGA,IAAID,aAAa,IAAIC,YAArB,EAAmC;UACjCT,OAAO,CAACS,YAAD,EAAeD,aAAf,CAAPR;UACAE,QAAQ,GAAG,IAAXA;QACD;MACF;MAED,IAAIA,QAAJ,EAAc;QACZT,WAAW,CAACC,KAAZD,CAAkBE,SAAlBF,CAAAA;QACAiB,aAAa,CAACP,QAAD,CAAbO;MACD;IACF;IAED,SAASH,aAAT,GAAyB;MACvB,IAAI,OAAON,OAAP,KAAmB,UAAvB,EAAmC;QACjCA,OAAO,EAAA;MACR;MAEDR,WAAW,CAACC,KAAZD,CAAkBE,SAAlBF,CAAAA;MACAiB,aAAa,CAACP,QAAD,CAAbO;IACD;EACF,CA5Ce;EA8ChBC,GA9CgB,EAAA,SAAA,GAAA,CA8CZxC,GA9CY,EA8CP;IACP,OAAOD,aAAa,CAACyC,GAAdzC,CAAkBC,GAAlBD,CAAP;EACD,CAhDe;EAkDhBoC,IAlDgB,EAAA,SAAA,IAAA,CAkDXnC,GAlDW,EAkDNyC,MAlDM,EAkDEC,OAlDF,EAkDW;IACzBtB,EAAE,IAAI,CAANA;IACA,IAAIK,KAAK,GAAG,IAAIkB,MAAM,CAACC,KAAX,EAAZ;IACAnB,KAAK,CAACC,OAAND,GAAgBiB,OAAhBjB;IAEAA,KAAK,CAACE,MAANF,GAAe,UAAA,CAAC,EAAI;MAElB,IAAIoB,QAAQ,GAARA,SAAAA,QAAW,GAAA;QAAA,OAAMJ,MAAM,CAAC;UAC1BK,WAAW,EAAEC;QADa,CAAD,CAAZ;MAAA,CAAf;MAIA,IAAI,OAAOtB,KAAK,CAACuB,MAAb,KAAwB,UAA5B,EAAwC;QAItCvB,KAAK,CAACuB,MAANvB,EAAAA,CAAewB,IAAfxB,CAAoBoB,QAApBpB,EAA8BoB,QAA9BpB,CAAAA;MACD,CALD,MAKO;QACLyB,UAAU,CAACL,QAAD,EAAW,CAAX,CAAVK;MACD;IACF,CAdDzB;IAgBAA,KAAK,CAAC0B,GAAN1B,GAAYzB,GAAZyB;IACAJ,QAAQ,CAAC,EAAA,GAAKD,EAAN,CAARC,GAAoBI,KAApBJ;IACA,OAAOD,EAAP;EACD,CA1Ee;EA4EhBgC,QA5EgB,EAAA,SAAA,QAAA,CA4EPpD,GA5EO,EA4EF;IACZ,OAAO,IAAIqD,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;MACtCjC,WAAW,CAACa,IAAZb,CAAiBtB,GAAjBsB,EAAsB,YAAM;QAG1BvB,aAAa,CAACyD,GAAdzD,CAAkBC,GAAlBD,CAAAA;QACAA,aAAa,CAAC0D,MAAd1D,CAAqBC,GAArBD,CAAAA;QACAuD,OAAO,EAAA;MACR,CANDhC,EAMGiC,MANHjC,CAAAA;IAOD,CARM,CAAP;EASD,CAtFe;EAwFhBoC,UAxFgB,EAAA,SAAA,UAAA,CAwFLC,IAxFK,EAwFC;IACf,IAAIC,MAAM,GAAG,CAAA,CAAb;IACAD,IAAI,CAACzC,OAALyC,CAAa,UAAA,CAAC,EAAI;MAChB,IAAI5D,aAAa,CAACyC,GAAdzC,CAAkB8D,CAAlB9D,CAAJ,EAA0B;QACxB6D,MAAM,CAACC,CAAD,CAAND,GAAY,aAAZA;MACD;IACF,CAJDD,CAAAA;IAKA,OAAON,OAAO,CAACC,OAARD,CAAgBO,MAAhBP,CAAP;EACD;AAhGe,CAAlB;AAmGA,eAAe/B,WAAf","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\nexport class ImageUriCache {\n  static has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  }\n\n  static add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  }\n\n  static remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  }\n\n  static _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(uri => {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  }\n\n}\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n\n  getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n\n  has(uri) {\n    return ImageUriCache.has(uri);\n  },\n\n  load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = e => {\n      // avoid blocking the main thread\n      var onDecode = () => onLoad({\n        nativeEvent: e\n      });\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n\n  prefetch(uri) {\n    return new Promise((resolve, reject) => {\n      ImageLoader.load(uri, () => {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n\n  queryCache(uris) {\n    var result = {};\n    uris.forEach(u => {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n\n};\nexport default ImageLoader;"]},"metadata":{},"sourceType":"module"}