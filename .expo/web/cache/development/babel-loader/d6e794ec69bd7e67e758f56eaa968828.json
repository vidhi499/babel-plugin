{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nexports.__esModule = true;\nexports.default = exports.ImageUriCache = void 0;\nvar dataUriPattern = /^data:/;\nvar ImageUriCache = function () {\n  function ImageUriCache() {\n    _classCallCheck(this, ImageUriCache);\n  }\n  _createClass(ImageUriCache, null, [{\n    key: \"has\",\n    value: function has(uri) {\n      var entries = ImageUriCache._entries;\n      var isDataUri = dataUriPattern.test(uri);\n      return isDataUri || Boolean(entries[uri]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(uri) {\n      var entries = ImageUriCache._entries;\n      var lastUsedTimestamp = Date.now();\n      if (entries[uri]) {\n        entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n        entries[uri].refCount += 1;\n      } else {\n        entries[uri] = {\n          lastUsedTimestamp: lastUsedTimestamp,\n          refCount: 1\n        };\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(uri) {\n      var entries = ImageUriCache._entries;\n      if (entries[uri]) {\n        entries[uri].refCount -= 1;\n      }\n      ImageUriCache._cleanUpIfNeeded();\n    }\n  }, {\n    key: \"_cleanUpIfNeeded\",\n    value: function _cleanUpIfNeeded() {\n      var entries = ImageUriCache._entries;\n      var imageUris = Object.keys(entries);\n      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n        var leastRecentlyUsedKey;\n        var leastRecentlyUsedEntry;\n        imageUris.forEach(function (uri) {\n          var entry = entries[uri];\n          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n            leastRecentlyUsedKey = uri;\n            leastRecentlyUsedEntry = entry;\n          }\n        });\n        if (leastRecentlyUsedKey) {\n          delete entries[leastRecentlyUsedKey];\n        }\n      }\n    }\n  }]);\n  return ImageUriCache;\n}();\nexports.ImageUriCache = ImageUriCache;\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n    function callback() {\n      var image = requests[\"\" + requestId];\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n          naturalWidth = image.naturalWidth;\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n    function errorCallback() {\n      if (typeof failure === \"function\") {\n        failure();\n      }\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n    image.onload = function (e) {\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n      if (typeof image.decode === \"function\") {\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = \"disk/memory\";\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nvar _default = ImageLoader;\nexports.default = _default;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/cjs/modules/ImageLoader/index.js"],"names":["exports","__esModule","default","ImageUriCache","dataUriPattern","uri","entries","_entries","isDataUri","test","Boolean","lastUsedTimestamp","Date","now","refCount","_cleanUpIfNeeded","imageUris","Object","keys","length","_maximumEntries","leastRecentlyUsedKey","leastRecentlyUsedEntry","forEach","entry","id","requests","ImageLoader","abort","requestId","image","onerror","onload","getSize","success","failure","complete","interval","setInterval","callback","load","errorCallback","naturalHeight","naturalWidth","clearInterval","has","onLoad","onError","window","Image","e","onDecode","nativeEvent","decode","then","setTimeout","src","prefetch","Promise","resolve","reject","add","remove","queryCache","uris","result","u","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = exports.ImageUriCache = void 0;\n\n/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\n\nclass ImageUriCache {\n  static has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  }\n\n  static add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  }\n\n  static remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  }\n\n  static _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(uri => {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  }\n\n}\n\nexports.ImageUriCache = ImageUriCache;\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n\n  getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n\n  has(uri) {\n    return ImageUriCache.has(uri);\n  },\n\n  load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = e => {\n      // avoid blocking the main thread\n      var onDecode = () => onLoad({\n        nativeEvent: e\n      });\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n\n  prefetch(uri) {\n    return new Promise((resolve, reject) => {\n      ImageLoader.load(uri, () => {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n\n  queryCache(uris) {\n    var result = {};\n    uris.forEach(u => {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n\n};\nvar _default = ImageLoader;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}