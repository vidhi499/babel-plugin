{"ast":null,"code":"\"use strict\";\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n    currentT,\n    i = 0,\n    aA = _aA,\n    aB = _aB;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error(\"bezier x values must be in [0, 1] range\");\n  }\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x;\n    }\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n;","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/vendor/react-native/Animated/bezier.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","_aA","_aB","mX1","mX2","currentX","currentT","i","aA","aB","Math","abs","newtonRaphsonIterate","_aGuessT","aGuessT","currentSlope","bezier","mY1","mY2","Error","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","BezierEasing","x"],"mappings":"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","sourcesContent":["/**\n * Portions Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n/**\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n * @copyright 2014-2015 GaÃ«tan Renaudeau. MIT License.\n */\n'use strict'; // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n;"]},"metadata":{},"sourceType":"module"}