{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nexports.__esModule = true;\nexports.addNode = addNode;\nexports.attachListeners = attachListeners;\nexports.getResponderNode = getResponderNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\nvar _utils = require(\"./utils\");\nvar _ResponderTouchHistoryStore = require(\"./ResponderTouchHistoryStore\");\nvar _canUseDom = _interopRequireDefault(require(\"../canUseDom\"));\nvar emptyObject = {};\nvar startRegistration = [\"onStartShouldSetResponderCapture\", \"onStartShouldSetResponder\", {\n  bubbles: true\n}];\nvar moveRegistration = [\"onMoveShouldSetResponderCapture\", \"onMoveShouldSetResponder\", {\n  bubbles: true\n}];\nvar scrollRegistration = [\"onScrollShouldSetResponderCapture\", \"onScrollShouldSetResponder\", {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nvar responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  if (eventType === \"touchstart\") {\n    isEmulatingMouseEvents = true;\n  }\n  if (eventType === \"touchmove\" || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  if (eventType === \"mousedown\" && isEmulatingMouseEvents || eventType === \"mousemove\" && isEmulatingMouseEvents || eventType === \"mousemove\" && trackedTouchCount < 1) {\n    return;\n  }\n  if (isEmulatingMouseEvents && eventType === \"mouseup\") {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent, responderTouchHistoryStore);\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n      id = _currentResponder.id,\n      node = _currentResponder.node;\n    var _getResponderConfig = getResponderConfig(id),\n      onResponderStart = _getResponderConfig.onResponderStart,\n      onResponderMove = _getResponderConfig.onResponderMove,\n      onResponderEnd = _getResponderConfig.onResponderEnd,\n      onResponderRelease = _getResponderConfig.onResponderRelease,\n      onResponderTerminate = _getResponderConfig.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = \"onResponderStart\";\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = \"onResponderMove\";\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || eventType === \"contextmenu\" || eventType === \"blur\" && eventTarget === window || eventType === \"blur\" && eventTarget.contains(node) && domEvent.relatedTarget !== node || isScrollEvent && trackedTouchCount === 0 || isScrollEvent && eventTarget.contains(node) && eventTarget !== node || isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches);\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = \"onResponderEnd\";\n          onResponderEnd(responderEvent);\n        }\n      }\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = \"onResponderRelease\";\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n        if (eventType === \"contextmenu\" || eventType === \"scroll\" || eventType === \"selectionchange\") {\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = \"onResponderTerminationRequest\";\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = \"onResponderTerminate\";\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n      nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id: id,\n            node: node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n        if (_result != null) {\n          return _result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n    currentId = _currentResponder2.id,\n    currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n    node = wantsResponder.node;\n  var _getResponderConfig2 = getResponderConfig(id),\n    onResponderGrant = _getResponderConfig2.onResponderGrant,\n    onResponderReject = _getResponderConfig2.onResponderReject;\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = \"onResponderGrant\";\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  } else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n    var allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = \"onResponderTerminationRequest\";\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = \"onResponderTerminate\";\n        onResponderTerminate(responderEvent);\n      }\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = \"onResponderGrant\";\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = \"onResponderReject\";\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\nvar documentEventsCapturePhase = [\"blur\", \"scroll\"];\nvar documentEventsBubblePhase = [\"mousedown\", \"mousemove\", \"mouseup\", \"dragstart\", \"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\", \"contextmenu\", \"select\", \"selectionchange\"];\nfunction attachListeners() {\n  if (_canUseDom.default && window.__reactResponderSystemActive == null) {\n    window.addEventListener(\"blur\", eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n    id = _currentResponder3.id,\n    node = _currentResponder3.node;\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n      onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\nfunction getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/cjs/modules/useResponderEvents/ResponderSystem.js"],"names":["_interopRequireDefault","require","default","exports","__esModule","addNode","attachListeners","getResponderNode","removeNode","terminateResponder","_createResponderEvent","_ResponderEventTypes","_utils","_ResponderTouchHistoryStore","_canUseDom","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","responderTouchHistoryStore","ResponderTouchHistoryStore","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isStartish","isPrimaryPointerDown","isMoveEvent","isMoveish","isEndEvent","isEndish","isScrollEvent","isScroll","isSelectionChangeEvent","isSelectionChange","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","getResponderPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","getLowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","isCancelish","window","contains","relatedTarget","hasValidSelection","isReleaseEvent","hasTargetTouches","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","__reactResponderSystemActive","addEventListener","forEach","document","setResponderId","set","has","delete","_currentResponder3","_getResponderConfig4","event"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.addNode = addNode;\nexports.attachListeners = attachListeners;\nexports.getResponderNode = getResponderNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\n\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\nvar _utils = require(\"./utils\");\n\nvar _ResponderTouchHistoryStore = require(\"./ResponderTouchHistoryStore\");\n\nvar _canUseDom = _interopRequireDefault(require(\"../canUseDom\"));\n\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nvar responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent, responderTouchHistoryStore);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || // native context menu\n      eventType === 'contextmenu' || // window blur\n      eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n      isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n      isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches); // End\n\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      } // Release\n\n\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n\n        changeCurrentResponder(emptyResponder);\n      } // Terminate\n\n\n      if (isTerminateEvent) {\n        var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          // Only call this function is it wasn't already called during negotiation.\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n\n        if (shouldSetCallback(responderEvent) === true) {\n          // Start the path from the potential responder\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id,\n            node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n        onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n    var allowTransfer = true;\n\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      } // Grant next responder\n\n\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\n\nfunction attachListeners() {\n  if (_canUseDom.default && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\n\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\n\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\n\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\n\nfunction getResponderNode() {\n  return currentResponder.node;\n}"]},"metadata":{},"sourceType":"script"}