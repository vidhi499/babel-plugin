{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.keyExtractor = keyExtractor;\nexports.newRangeCount = newRangeCount;\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n        if (kk === offsets.length - 1) {\n          (0, _invariant.default)(outLength === offsets.length, \"bad offsets input, should be in increasing order: %s\", JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\nfunction computeWindowedRenderLimits(data, getItemCount, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  var offset = scrollMetrics.offset,\n    velocity = scrollMetrics.velocity,\n    visibleLength = scrollMetrics.visibleLength;\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n  var leadFactor = 0.5;\n  var fillPreference = velocity > 1 ? \"after\" : velocity < -1 ? \"before\" : \"none\";\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], itemCount, getFrameMetricsApprox),\n    overscanFirst = _elementsThatOverlapO[0],\n    first = _elementsThatOverlapO[1],\n    last = _elementsThatOverlapO[2],\n    overscanLast = _elementsThatOverlapO[3];\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  };\n  var newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === \"after\" && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === \"before\" && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error(\"Bad window calculation \" + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n  return {\n    first: first,\n    last: last\n  };\n}\nfunction keyExtractor(item, index) {\n  if (typeof item === \"object\" && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n  if (typeof item === \"object\" && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n  return String(index);\n}","map":{"version":3,"sources":["/Users/VidhiKataria/Documents/Projects/testing123/node_modules/react-native-web/dist/cjs/vendor/react-native/VirtualizeUtils/index.js"],"names":["_interopRequireDefault","require","default","exports","__esModule","computeWindowedRenderLimits","elementsThatOverlapOffsets","keyExtractor","newRangeCount","_invariant","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","prev","next","last","first","Math","max","min","data","getItemCount","maxToRenderPerBatch","windowSize","getFrameMetricsApprox","scrollMetrics","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","item","index","key","id","String"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.keyExtractor = keyExtractor;\nexports.newRangeCount = newRangeCount;\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(data, getItemCount, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], itemCount, getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first,\n    last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first,\n      last,\n      itemCount,\n      overscanFirst,\n      overscanLast,\n      visible\n    }));\n  }\n\n  return {\n    first,\n    last\n  };\n}\n\nfunction keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n\n  return String(index);\n}"]},"metadata":{},"sourceType":"script"}